[{"categories":["OS"],"content":"Vagrant 基础使用","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"使用 Vagrant 搭建开发测试环境 Vagrant Vagrant 基于工业标准化技术至上提供了易于配置，可重复部署以及可移植的工作环境，并且通过一个简单的一致性的工作流提供控制来帮助你和你的团队最大化生产力和可伸缩性。 为了实现这个奇迹，Vagrant 站在了巨人的肩膀之上。主机由 VirtualBox，VMware，AWS 或其他 provider 提供。然后，工业标准化的供给工具，例如 shell 脚本，Chef 或 Puppet，可以提供自动化安装和配置主机中的软件。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:0:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Vagrant 优势 对于开发者而言，Vagrant 隔离了依赖和它们的配置到一个单一的一次性的，一致性的环境，不需要担忧任何使用的工具。一旦你或者其他人创建了一个 Vagrant 文件，你只需要使用 vagrant up 然后，所有软件被安装和配置。其他团队成员也适用相同的配置文件创建他们的环境，无论你们是工作在 Linux， Mac OS X 或 Windows 。所有团队成员在相同环境中运行代码，基于相同的依赖。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:1:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"使用 Vagrant 部署环境 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:2:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Get Started 安装 vagrant ，对于 archlinux 可以使用 pacman 直接安装 vagrant 和 virtualbox $ sudo pacman -S vagrant virtualbox 对于其他发行版，可以自行到官网下载安装： VirtualBox Vagrant 创建一个虚拟机： 首先，到 Vagrant Cloud 找到需要安装的虚拟机，注意选择 virtualbox 格式的 box。 $ mkdir ~/Vagrant/ubuntu2004 $ cd ~/Vagrant/ubuntu2004 $ vagrant init generic/ubuntu2004 $ vagrant up 虚拟机搭建完成后，通过vagrant ssh 即可进行连接。 Notice：对于 kitty terminal ，需要使用 TERM=xterm-256color vagrant ssh，问题具体描述，参见：reddit ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:2:1","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Vagrantfile Vagrantfile 配置任何 Vagrant 项目的第一步是创建一个 Vagrantfile。这个 Vagrantfile 两个作用： 标记项目的根目录，一些 Vagrant 配置归属到这个根目录中 描述主机类型和需要运行项目的资源，例如软件安装以及如何访问它 Vagrant 有一个内建命令来初始化目录 vagrant init 。这个命令将 Vagrantfile 放到当前目录，可以查看这个文件（包含了很多注释和例子）。也可以在已经存在的目录执行 vagrant init 来设置 Vagrant。 Vagrantfile 实际是使用 Ruby 语法，但如果不熟悉 Ruby，也无伤大雅，没有必要为此学习 Ruby。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:2:2","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Box Vagrant 使用一个基础镜像来 clone 虚拟机，这个基础镜像称为 boxes。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:2:3","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"修改 synced 目录 可以通过修改 Vagrantfile 配置来实现对默认共享目录位置的修改，例如 config.vm.synced_folder \"/home/allen/Workplace/eBPF/Vagrant/allen\", \"/allen\" 可以用来在不同的虚拟机之间使用共享目录，这样方便部署一个简单的共享集群。即，在物理服务器上构建一个共享给多个虚拟机使用的网络存储（不需要单独部署 NFS 或者 CIFS），方便构建测试集群。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:2:4","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Vagrant Package 可以使用 vagrant package 是一个将当前的虚拟环境打包成一个可以重用的 box ，但 vagrant package 不能用于其他的provider。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:3:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"简单的打包 进入 Vagrant 项目目录，执行简单的命令 vagrant package ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:3:1","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"参数 --base NAME - 替代打包一个 VirtualBox 主机，这个参数打包一个 VirtualBox manages 的 VirtualBox。这里 NAME 是 VirtualBox GUI 中显示的虚拟机的 UUID 或者名字。 --output NAME - 这个参数设置打包的名字，如果没有这个参数，则默认保存为 package.box --include x,y,z - 附加一些文件到 box 中，这是让打包 Vagrantfile 执行附加任务 --vagrantfile FILE - 打包一个 Vagrantfile 到 box 中，这个 Vagrantfile 将作为 box 使用的 Vagrantfile load vagrant package --base ubuntu2004 --output ubuntu2004.box ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:3:2","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Vagrant ❤️ Libvirt Vagrant 非常适合支持桌面级虚拟化 VirtualBox，不过在生产环境中，通常会部署 KVM 或 Xen 环境。Vagrant 通过 libvirt 支持不同的虚拟化环境，同样也包括了 KVM／Qemu。Vagrant 提供了易于部署和管理的包装，以便快速部署和方便管理 VM。 该部分是在已搭建好 KVM 的基础上进行的，KVM 搭建过程具体参考：在 CentOS 7 中部署 KVM ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:4:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"安装 Vagrant Plugins vagrant-libvirt 该插件用于支持 libvirt vagrant plugin install vagrant-libvirt 这需要你事先安装好 libvirt-devel,否则会报错。 vagrant-mutate 插件将官方的 Vagrant guest box 转换成 KVM 格式 vagrant plugin install vagrant-mutate vagrant-rekey-ssh - 由于官方的 Vagrant boxes 使用了内建的非安全的 SSH key，所以我们可以使用vagrant-rekey-ssh插件来重新生成新的 SSH key vagrant plugin install vagrant-rekey-ssh ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:4:1","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"使用 vagrant-libvirt 安装 Ubuntu20.04 初始化 ubuntu2004 box (ubuntu2004) vagrant init generic/ubuntu2004 Vagrant会尝试使用一个名为default的存储池，如果这个default存储池不存在就会尝试在/var/lib/libvirt/images上创建这个defualt存储池。 Vagrant.configure(\"2\") do |config| ... config.vm.provider :libvirt do |libvirt| libvirt.storage_pool_name = \"default\" end ... end 如果希望默认使用 vagrant 作为 provider 需要设置相应的环境变量 export VAGRANT_DEFAULT_PROVIDER=libvirt 启动安装 vagrant up 也可以在安装时指定provider vagrant up --provider libvirt 查看系统的储存池 virsh pool-list --all Name State Autostart ------------------------------------------- huatai active yes images active yes root active yes 一些故障，请参考：使用 Vagrant 部署 kvm 虚拟化(libVirt) ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:4:2","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Vagrant Box 管理 Boxes 是 Vagrant 环境的打包格式。一个 box 可以被任何 Vagrant 所支持的平台的任何人用于启动一个独立工作的环境。 vagrant box 工具提供了所有的管理 boxes 的功能。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:5:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"探索 Boxes 在 public Vagrant box catalog 上提供了支持各种虚拟化，如 VirtualBox，VMware，AWS 等。简单添加到本机的命令如下： vagrant box add username/boxname ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:5:1","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"快速复制 Vagrant Box 当需要复制出 Vagrant box 时，简单的方法如下： 关闭 box (如果 box 正在运行的话) vagrant halt 将环境打包 vagrant package --output ubuntu2004.box 创建新的 box 文件 mkdir devstack cd devstack vagrant init 编辑 vagrantfile ,修改如下内容： config.vm.box = \"ubuntu2004\" config.vm.box_url = \"file:///home/allen/Workplace/eBPF/vagrant/ubuntu2004.box\" config.vm.network \"private_network\", ip: \"192.168.33.101\" # 可选 这里的 vagrant init，命令可以改成 vagrant box add ubuntu2004 /home/allen/Workplace/eBPF/vagrant/ubuntu2004.box libvirt 这样就不需要再修改 Vagrantfile 此时只需要直接运行下一步 vagrant up 就可以了。 运行 Vagrant box vagrant up vagrant ssh ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:5:2","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"删除 box 进入相应目录 cd devstack vagrant destroy 执行后将从 VirtualBox 中删除掉虚拟机配置以及虚拟机相关的虚拟磁盘，真正释放空间。 然后执行 vagrant box remove devstack 将 Vagrant 对应的 devstack 配置清理掉。 ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:5:3","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"使用 vagrant Snapshot 创建快照备份 使用 Vagrant 的快照功能可以很方便快速的创建当前虚拟机的一个临时备份状态，在进行重要操作时可以先创建一个快照以便在操作失误后快速恢复。 vagrant plugin install vagrant-snapshot 支持的参数如下： vagrant snapshot take [vm-name] \u003cSNAPSHOT_NAME\u003e # take snapshot, labeled by NAME vagrant snapshot list [vm-name] # list snapshots vagrant snapshot back [vm-name] # restore last taken snapshot vagrant snapshot delete [vm-name] \u003cSNAPSHOT_NAME\u003e # delete specified snapshot vagrant snapshot go [vm-name] \u003cSNAPSHOT_NAME\u003e # restore specified snapshot ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:6:0","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"使用方法： 创建一个快照 vagrant snapshot take centos-7.1 centos-7.1_base 当前目录是 Vagrant 配置文件所在目录 centos-7.1 ，我以为虚拟机的名字是 centos-7.1 （不过看 VirtualBox 的图形管理界面中显示的是 Vagrant_default_1448250085458_10997），但是实际上述命令执行会提示错误 The machine with the name 'centos-7.1' was not found configured for this Vagrant environment. 那么真正的名字是什么呢？使用vagrant status 可以查看当前虚拟机的信息。 Current machine states: default poweroff (virtualbox) The VM is powered off. To restart the VM, simply run `vagrant up` 原来名字是defualt vagrant snapshot take default centos-7.1_base 查看快照列表： vagrant snapshot list 输出： Listing snapshots for 'default': Name: centos-7.1_base (UUID: af5b803c-266e-41af-875b-9f7a2bc36794) * 回滚到快照： vagrant snapshot go \"centos-7.1_base\" 删除快照 vagrant snapshot delete \"centos-7.1_base\" ","date":"2022-04-20","objectID":"https://allen191819.xyz/vagrant/:6:1","tags":["Container \u0026 Virtualization"],"title":"Vagrant","uri":"https://allen191819.xyz/vagrant/"},{"categories":["OS"],"content":"Do you know Docker \u0026 Vagrant?","date":"2022-04-19","objectID":"https://allen191819.xyz/container/","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":" 初探 Docker 与 Vagrant 简记 Container ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:0:0","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"容器概述 容器是一种沙盒技术，主要目的是为了将应用运行在其中，与外界隔离；及方便这个沙盒可以被转移到其它宿主机器。本质上，它是一个特殊的进程。通过名称空间（Namespace）、控制组（Control groups）、切根（chroot）技术把资源、文件、设备、状态和配置划分到一个独立的空间。 Linux Container 容器技术的诞生（2008 年）就解决了 IT 世界里“集装箱运输”的问题。Linux Container（简称 LXC）它是一种内核轻量级的操作系统层虚拟化技术。Linux Container 主要由 Namespace 和 Cgroup 两大机制来保证实现。那么 Namespace 和 Cgroup 是什么呢？刚才我们上面提到了集装箱，集装箱的作用当然是可以对货物进行打包隔离了，不让 A 公司的货跟 B 公司的货混在一起，不然卸货就分不清楚了。那么 Namespace 也是一样的作用，做隔离。光有隔离还没用，我们还需要对货物进行资源的管理。同样的，航运码头也有这样的管理机制：货物用什么样规格大小的集装箱，货物用多少个集装箱，货物哪些优先运走，遇到极端天气怎么暂停运输服务怎么改航道等等… 通用的，与此对应的 Cgroup 就负责资源管理控制作用，比如进程组使用 CPU/MEM 的限制，进程组的优先级控制，进程组的挂起和恢复等等。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:1:0","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Namespace 每个运行的容器都有自己的名称空间。这是 Linux 操作系统默认提供的 API，包括： PID Namespace：不同容器就是通过 pid 名字空间隔离开的，不同名字空间中可以有相同的 pid。 Mount Namespace：mount 允许不同名称空间的进程看到的文件结构不同，因此不同名称空间中的进程所看到的文件目录就被隔离了。另外，每个名称空间中的容器在/proc/mounts 的信息只包含当前名称的挂载点。 IPC Namespace：容器中进程交互还是采用 Linux 常见的进程交互方法（interprocess communication -IPC），包括信号量、消息队列和共享内存等。 Network Namespace：网络隔离是通过 Net 实现，每个 Net 有独立的网络设备，IP 地址，路由表，/proc/net 目录。这样每个容器的网络就能隔离开来。 UTS Namespace：UTS（UNIX Time-sharing System）允许每个容器拥有独立的 hostname 和 domain name，使其在网络上可以被视作一个独立的节点而非主机上的一个进程。 User Namespace：每个容器可以有不同的用户和组 id，也就是说可以在容器内用容器内部的用户执行程序而非主机上的用户。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:1:1","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"控制组(Control groups) Cgroups 是 Linux 内核提供的一种可以限制、记录、隔离进程组的物理资源机制。因为 Namespace 技术只能改变进程的视觉范围，不能真实地对资源做出限制。所以就必须采用 Cgroup 技术对容器进行资源限制，防止某个容器把宿主机资源全部用完导致其它容器也宕掉。在 Linux 的/sys/fs/cgroup 目录中，有 cpu、memory、devices、net_cls 等子目录，可以根据需要修改相应的配置文件来设置某个进程 ID 对物理资源的最大使用率。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:1:2","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"切根(change to root) 切根就是指改变一个程序与形式参考的根目录的位置，让不同的容器在不同的虚拟根目录下工作而互不影响。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:1:3","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"容器与虚拟机 容器，也是虚拟层的概念，相对虚拟机而言，容器更加轻量级。虚拟机中需要模拟一台物理机的所有资源，比如你要模拟出有多少 CPU、网卡、显卡等等，这些都是在软件层面通过计算资源实现的，这就给物理机凭空增加了不必要的计算量。容器仅仅在操作系统层面向上，对应用的所需各类资源进行了隔离。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:1:4","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Docker 附：中文文档 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:2:0","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Docker 的理念 通过 Docker 官方提供的架构图来看看 Docker 对容器结构的设计。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:2:1","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Docker 的四大对象 在 Docker 体系里，有四个对象 ( Object ) 是不得不进行介绍的，因为几乎所有 Docker 以及周边生态的功能，都是围绕着它们所展开的。它们分别是： 镜像 ( Image ) 容器 ( Container ) 网络 ( Network ) 数据卷 ( Volume ) Image 镜像就是一个包含了虚拟环境运行最原始文件系统的内容的只读文件。 Docker 的镜像与虚拟机中的镜像还是有一定区别的。首先，Docker 中的一个创新是利用了 AUFS 作为底层文件系统实现，通过这种方式，Docker 实现了一种增量式的镜像结构。 Docker 的镜像实质上是无法被修改的，因为所有对镜像的修改只会产生新的镜像，而不是更新原有的镜像。 Container 类比 Oop ，镜像就像是一个类，而容器则可以理解为该类的实例。 根据官方的定义，一个 Docker 容器应该包括一下三项内容： 一个 Docker 镜像 一个程序的运行环境 一个指令集合 Network 网络通讯作为目前最常用的一种程序间的数据交换方式。 Docker 中，实现了强大的网络功能，我们不但能够十分轻松的对每个容器的网络进行配置，还能在容器间建立虚拟网络，将数个容器包裹其中，同时与其他网络环境隔离。 Volume Docker 能够这么简单的实现挂载，主要还是得益于 Docker 底层的 Union File System 技术。在 UnionFS 的加持下，除了能够从宿主操作系统中挂载目录外，还能够建立独立的目录持久存放数据，或者在容器间共享。 在 Docker 中，通过这几种方式进行数据共享或持久化的文件或目录，我们都称为数据卷 ( Volume )。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:2:2","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Vagrant Vagrant 是一个虚拟机管理软件，可以自动化虚拟机的安装和配置流程。一般我们使用虚拟机时是这样的，安装一个虚拟机软件 VMware 或 VirtualBox，寻找我们需要的 iso 镜像文件，然后一步步的在 VMware 上安装这个镜像文件，安装好之后，再一步步配置这个这个虚拟机的开发环境或运行环境。如果我们需要安装两个或多相同的虚拟机环境怎么办？还是得这样一步步的安装？不，我们有 Vagrant。Vagrant 让你通过编写一个 Vagrantfile 配置文件来控制虚拟机的启动、销毁、与宿主机间的文件共享、虚拟机网络环境的配置，还可以编写一些虚拟机启动后的执行脚本，自动安装一些必备的开发工具或配置。 并且 Vagrant 还允许移植的你的虚拟机，使你只需要一次搭建就可以拥有多个相同环境的虚拟机副本。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:3:0","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Vagrant 的优点 跨平台 可移动 自动化部署无需人工参与等 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:3:1","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Vagrant 的相关概念 Vagrant 是一个虚拟机管理软件，它是用来管理虚拟机的，它自己并不是一个虚拟机软件。这意味着你必须独立安装一个虚拟机软件 VMware 或 VirtualBox 做支持。VMware 应该都很熟不多说了。VirtualBox 是一款开源虚拟机软件。VirtualBox 是由德国 Innotek 公司开发，由 Sun Microsystems 公司出品的软件，目前在 oracle 旗下。早期，Vagrant 只支持 VirtualBox，后来才加入了 VMWare 的支持。当然目前也支持 KVM，目前我的学习环境就是选择 KVM 作为虚拟化工具。 .box 文件 这是 Vagrant 使用的镜像，它与传统的镜像不太一样，它不是待安装的系统镜像，而是从虚拟机中导出的、对已经安装配置好的操作系统的快照。.box 文件是个压缩文件包，里面除了基础数据的镜像外，还包括一些元数据文件，用来指导 Vagrant 将系统镜像正确的加载到对应的虚拟机当中中。所以这边要注意 box 文件是依赖虚拟机软件的，比如 VMware 下的 box 文件是无法在 VirtualBox 上使用的。 vagrantfile vagrantfile 是一个配置文件。每一个 vagrantfile 对应一个 box 镜像，在初始化虚拟机的时候会制自动生成 vagrantfile 文件。我们可以在 vagrantfile 文件里添加启动的脚本，网络配置，启动后的脚本等等。在启动时 vagrant 就会读取相应的 vagrantfile 中的指令来搭建虚拟机环境。Vagrant 是使用 Ruby 开发的，所以它的 vagrantfile 配置文件语法也是 Ruby 的，但是 Vagrant 定义了自己的语法规则，我们也没有必要去学习 Ruby。关于更多 vagrantfile 的配置文件信息后面会单独介绍，这边就不复述了。 另外默认 vagrantfile 所在的目录，就是宿主机同虚拟机共享的目录。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:3:2","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["OS"],"content":"Vagrant 与 Docker 首先，相似之处是 Vagrant 和 Docker 都是虚拟化技术。Vagrant 是基于 Virtualbox 的虚拟机来构建你的开发环境，而 Docker 则是基于 LXC(LXC)轻量级容器虚拟技术。全面理解这两种虚拟技术的区别，需要阅读很多文档。我这里打个简单的比方，虚拟机之于容器虚拟技术相当于进程和线程。虚拟机内可以包含很多容器，正如一个进程中可以包含很多线程。虚拟机重，容器虚拟技术轻。 前者的 Image 一般以 GB 计算，Docker 则以 100MB 为单位计算。当然，提问者肯定更希望从应用层面来了解两者的区别。简单点讲，Vagrant 就是你的开发环境的部署工具；而 docker 是你的运行环境部署工具。 个人感觉 Vagrant 和 Docker 类似，通过组合底层开源技术加上自己开发的程序/脚本以及良好定义的规则，实现了标准化的快速部署虚拟系统的架构。所不同的是，Docker 采用的是轻量级的容器技术，Vagrant 则使用 kvm/virtualbox 等重量级的全/半虚拟化平台。 Vagrant 实现的是根据模版快速提供虚拟系统，大规模生产虚拟系统，需要结合进一步定制的管理控制平台来实现 PaaS。 Vagrant 更适合部署完全虚拟化集群，可以实现更为复杂的系统模拟，在特定的需要安全性隔离环境以及需要实现完整的操作系统功能的虚拟系统。 ","date":"2022-04-19","objectID":"https://allen191819.xyz/container/:4:0","tags":["Container \u0026 Virtualization"],"title":"Docker 与 Vagrant 初探","uri":"https://allen191819.xyz/container/"},{"categories":["Entertainment"],"content":"Ava 向晚","date":"2022-04-10","objectID":"https://allen191819.xyz/ava/","tags":["Asoul","Ava"],"title":"水母 水母 如此脆弱的生物","uri":"https://allen191819.xyz/ava/"},{"categories":["Entertainment"],"content":"Avavavavavavavavavavavavav! 水母之歌 有时也会厌烦逆来顺受的自己 偶尔也会放空大脑 期待天降的转机 海浪带我去哪里 我就去哪里 伤人的词语无法传播 水下安静到窒息 水母 水母 普通透明的生物 期待委婉的保护 不再 复述 相对失败的酸楚 尝试享受着独处 请来一束追光 照亮这海底 学会人间技巧 参与了游戏 反正眼泪可以融化在海里 散漫自在也被视为你恣意 水母 水母 普通透明的生物 期待委婉的保护 不再 复述 相对失败的酸楚 尝试享受着独处 努力生长了刺 却没学会保护自己 现在说出愿望 讨一个拥抱来不来得及 见不到想见的世界和尽头的你 想过变换姿态只能反射阳光的色彩 水母 水母 普通透明的生物 期待委婉的保护 不再 复述 相对失败的酸楚 尝试享受着独处 请来一束追光 照亮这海底 学会人间技巧 参与了游戏 反正眼泪可以 融化在海里 散漫自在也被视为你恣意 水母水母 随波逐流的生物 等一个短暂的停驻 逐渐领悟 缓慢弥补的脚步 终会找到 归属 Spring 还记得吗，在还是种子的时候 我们相遇时你皱了皱眉头 我害怕春天她无法承受阳光 不能绽放成你期待的模样 是风吗，在吹拂我的枝桠 是你呀，说要守护我长大 我得到的爱已经足够比如说你陪伴你的照料 可我能给你的，我看不到 不能出声的我，多羡慕鸟儿啊 不能动弹的我，多羡慕蝴蝶啊 可以为你歌唱为你舞蹈为你抚平悲伤啊 也可能是春天，太美丽了吧 有人说讨厌我嬉笑吵闹 可你总解释我天生爱开玩笑 有人说ta爱我情绪难了 你为我浇水告诉我不用急躁 是雨吗，浸润我的身体啊 是你啊，还在等待我长大 我每天都为明天而活可明天还来不及看到 何时才能发芽，让你看看我啊 我不是泥土里，这样丑陋的啊 我不是黑暗里，这样沮丧的啊 多想为你歌唱为你舞蹈为你抚平悲伤啊 只能等到春天的美丽来吧 我在的城下雨了 夕阳下她 倚靠着墙壁 五彩霞光 点缀她眼睛 打闹中留下 膝盖的印记 换哪种语言解释 才算合理 发呆海龟 调整着呼吸 普通水母 告别了海底 讲个冷笑话 形容这场景 你能听得到吗？ 蚝喜欢泥 我本以为 人生啊 只有劳累 只有挣扎 可现在天使悄悄 从云间落下 她说世界 不会轻易崩塌 哪些是真 哪些是假 谁在装疯 谁在作哑 每个人生来都是一个 贪心的傻瓜 为了被爱 干脆当个笑话 顶着暴雨 赴一个约定 晚风敲打 撑伞的手臂 人越是长大 越渴望真心 爱就藏在这里 你听仔细 慕然回首 时间已老去 马上回忆 就填满日记 你仍在笑着 我那么熟悉 一起安静期待 下个雨季 我本以为 平凡啊 虚度人间 多少年华 在寻找爱的路上 总是会摔摔打打 只想找人 简单拥抱一下 我在的城 下雨啦 怎么就这么 想起你啊 单纯的喜欢 它又没有什么筹码 说句爱你 应该不太复杂 就慢些吧 时光啊 让我能把 心意传达 集合六百一十二种 说爱的方法 做环绕你 保护你的浪花 ","date":"2022-04-10","objectID":"https://allen191819.xyz/ava/:0:0","tags":["Asoul","Ava"],"title":"水母 水母 如此脆弱的生物","uri":"https://allen191819.xyz/ava/"},{"categories":["Haskell"],"content":"Haskell I/O","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"输入与输出 Haskell Learning ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:0:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"输入与输出 在 Haskell 中，一个函数不能改变状态，像是改变一个变量的内容。（当一个函数会改变状态，我们说这函数是有副作用的。） 函数无法改变状态的好处是它让我们促进了我们理解程序的容易度，但同时也造成了一个问题。假如说一个函数无法改变现实世界的状态，那它要如何打印出它所计算的结果？毕竟要告诉我们结果的话，它必须要改变输出设备的状态（譬如说屏幕），然后从屏幕传达到我们的脑，并改变我们心智的状态。 不要太早下结论，Haskell 实际上设计了一个非常聪明的系统来处理有副作用的函数，它漂亮地将我们的程序区分成纯粹跟非纯粹两部分。非纯粹的部分负责跟键盘还有屏幕沟通。有了这区分的机制，在跟外界沟通的同时，我们还是能够有效运用纯粹所带来的好处，像是惰性求值、容错性跟模块性。 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:1:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"运行一个 Haskell 程序 编译运行： $ ghc --make helloworld $ ./helloworld 使用 runhaskell 命令运行 $ runhaskell code.hs ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:1:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"Hello world 在一个 Haskell 程序中输出文字需要定义一个 main 函数： main = putStrLn \"Hello World\" 其中 putStrLn 的类型是： $$putStrLn :: String \\to IO ()$$ putStrLn 接收一个 String 类型，并返回一个结果为()类型的 IO 动作（I/O action）。所以 main 函数的类型为 IO ()。（IO 的 Kind 是 _ -\u003e _） 除此之外，还有其他默认提供的输出文本的函数： putStr：输出文本，结尾不换行 putChar：输出单个字符，结尾不换行。接收的参数为单个 Char，不是 String（用单引号不是双引号） print：可以接收任何 Show 的成员，先用 show 转化为字符串然后输出。等同于 putStrLn . show ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:1:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"do block 在 main 函数中使用多个 putStrLn 需要使用 do 语句： main = do putStrLn \"晚宝晚宝 陪你到老\" putStrLn \"傲娇双钻 我的老伴\" 其中最后一行一定要返回 IO () 类型的值 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:1:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"输入文本 输入文字需要在 do 块中使用 getLine： main = do line \u003c- getLine putStrLn line getLine 的类型是： $$getLine :: IO String$$ 而 \u003c- 操作符将 getLine 中的 String 提取了出来给到了 line，使 line 变成了 String 类型的一个字符串。 而且使用输入的字符串必须要经过一次 \u003c-，不能直接使用 getLine 作为字符串，因为 getLine 不是 String 类型，而是 IO String 类型。 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:1:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"其他 IO 相关函数用法 return Haskell 中的 return 和其他命令式语言中的 return 完全不同，它不会使函数直接结束并返回一个值。 main 函数必须定义为类型为 IO ()的函数，所以在 main 函数中使用 if 语句，如果不输出的话也不可以直接放下什么都不干，因为这时候 main 函数的类型不是 IO ()。所以这时需要使用 return () 来为 main 函数指定为 IO ()类型，例如： main = do line \u003c- getLine if null line then return () -- \u003c-这里 else do ... 使用 \u003c- 操作符也可以直接将 return 语句中的内容提取出来，比如 a \u003c- return ‘A’，执行后 a 就是’A’。 when when 包含在 Control.Monad 模块中，它表示在满足第一个参数的条件下会执行第二个函数，否则会 return ()。比如： import Control.Monad main = do c \u003c- getChar when (c /= ' ') $ do putChar c main 等同于： main = do c \u003c- getChar if c /= ' ' then do putChar c main else return () sequence sequence 在 IO 中使用时可以达成 [IO a] -\u003e IO [a] 的效果，所以可以用作： [a, b, c] \u003c- sequence [getLine, getLine, getLine] mapM \u0026 mapM_ 在 IO 相关的地方使用 map，可以使用 mapM 和 mapM_，其中 mapM 有返回值而 mapM_ 直接扔掉了返回值： ghci\u003e mapM print [1,2,3] 1 2 3 [(),(),()] ghci\u003e mapM_ print [1,2,3] 1 2 3 forever forever 函数包含在 Control.Monad 模块中。在 main 函数开头加上 forever 函数可以使后面的 do 块一直重复执行直到程序被迫终止，如： import Control.Monad main = forever $ do ... forM forM 函数包含在 Control.Monad 模块中，它的功能和 mapM 类似，从第一个参数中逐个取出元素传入第二个参数（一个接收一个参数的函数）中，并且第二个参数可以返回 IO a 类型。比如： import Control.Monad main = do colors \u003c- forM [1, 2, 3, 4] (\\a -\u003e do putStrLn $ \"Which color do you associate with the number \" ++ show a ++ \"?\" color \u003c- getLine return color) putStrLn \"The colors that you associate with 1, 2, 3 and 4 are: \" mapM putStrLn colors getContents getLine 获取一整行，而 getContents 从标准输入中获取全部内容直到遇到 EOF，并且它是 lazy 的，在执行了 foo \u003c- getContents 后，它并不会读取标准输入并且赋值到 foo，而是等到需要使用 foo 的时候再从标准输入读取。 getContents 在使用管道传入文字时很常用，可以代替 forever + getLine 使用，比如一个 Haskell 程序文件 code.hs： import Data.Char main = do contents \u003c- getContents putStr (map toUpper contents) 使用管道传入文本： cat text.txt | ./code interact String -\u003e String 类型的函数在输入输出中的使用太常见了，所以可以使用 interact 函数来简化。interact 的类型是： $$interact :: (String \\to String) \\to IO ()$$ 可以看出它接收一个 String -\u003e String 的函数，并返回一个 IO ()类型，所以可以直接用在 main 上。 转换大写的程序就可以这样实现： main = interact $ unlines . map (map toUpper) . lines ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:1:5","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"文件与流 文件与流的相关函数都包含在 System.IO 模块中： ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"openFile $$openFile :: FilePath \\to IOMode \\to IO\\ Handle$$ 其中 FilePath 是 String 的 type synonyms，用一个字符串来表示需要打开的文件的路径 IOMode 的定义是： data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode openFile 返回一个 IO Handle 类型的值，将其用\u003c-操作符提取后会出现一个 Handle 的值。但不能从 Handle 中直接使用文字，还需要使用一系列函数： hGetContents :: Handle -\u003e IO String ，从 Handle 中读取全部内容，返回一个 IO String hGetChar :: Handle -\u003e IO Char ，从 Handle 中读取一个字符 hGetLine :: Handle -\u003e IO String ，从 Handle 中读取一行，返回一个 IO String hPutStr :: Handle -\u003e String -\u003e IO () ，向 Handle 中输出字符串 hPutStrLn :: Handle -\u003e String -\u003e IO () ，同上 在使用 openFile 进行文件操作后，需要使用 hClose 手动关闭 Handle。 $$hClose :: Handle \\to IO ()$$ 接收一个 Handle 并返回 IO ()，可以直接放在 main 函数末尾 所以使用 openFile 读取一个文件中的全部内容并输出的全部代码是： import System.IO main = do handle \u003c- openFile \"test.txt\" ReadMode contents \u003c- hGetContents handle putStrLn contents hClose handle ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"withFile withFile 类似 Python 中的 with open，它在读取文件使用之后不需要手动 close 文件。它的类型是： $$withFile :: FilePath \\to IOMode \\to (Handle \\to IO a) \\to IO a$$ 可以看出，它接收三个参数： FilePath：一个表示文件路径的 String IOMode：打开文件的模式 (Handle -\u003e IO a)：一个函数，表示对读取文件后的 Handle 索要进行的操作，需要返回一个 I/O action；而这个返回值也将作为 withFile 的返回值 import System.IO main = withFile \"text.txt\" ReadMode (\\handle -\u003e do contents \u003c- hGetContents handle putStrLn contents) ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"readFile readFile 可以更加简化读取文件内容的操作，它的类型： $$readFile :: FilePath \\to IO String$$ 它只需要输入一个表示文件路径的字符串，返回其中以其中内容为内容的 I/O action： import System.IO main = do contents \u003c- readFile \"text.txt\" putStrLn contents ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"writeFile writeFile 简化了写入文件的操作，它的类型： $$writeFile :: FilePath \\to String \\to IO ()$$ 传入的第一个参数是要写入的文件的路径，第二个参数是要写入的字符串，返回一个 IO () ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"appendFile appendFile 类似 writeFile，但使用它不会覆盖文件中原来内容，而是直接把字符串添加到文件末尾 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:5","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"buffer 文件以流的形式被读取，默认文字文件的缓冲区 buffer 大小是一行，即每次读取一行内容；默认二进制文件的缓冲区大小是以块为单位，如果没有指定则根据系统默认来选择。 也可以通过 hSetBuffering 函数来手动设置缓冲区大小，这个函数的类型： $$hSetBuffering :: Handle \\to BufferMode \\to IO ()$$ 它接收一个 handle，和一个 BufferMode，并返回 IO ()。其中 BufferMode 有以下几种： NoBuffering：没有缓冲区，一次读入一个字符 LineBuffering：缓冲区大小是一行，即每次读入一行内容 BlockBuffering (Maybe Int)：缓冲区大小是一块，块的大小由 Maybe Int 指定： BlockBuffering (Nothing)：使用系统默认的块大小 BlockBuffering (Just 2048)：一块的大小是 2048 字节，即每次读入 2048bytes 的内容 缓冲区的刷新是自动的，也可以通过 hFlush 来手动刷新 $$hFlush :: Handle \\to IO ()$$ 传入一个 handle，返回 IO ()，即刷新对应 handle 的缓冲区 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:6","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"openTempFile openTempFile 可以新建一个临时文件： $$openTempFile :: FilePath \\to String \\to IO (FilePath, Handle)$$ FilePath 指临时文件要创建的位置路径，String 指临时文件名字的前缀，返回一个 I/O action，其内容第一个 FilePath 是创建得到的临时文件的路径，Handle 是临时文件的 handle 例如： import System.IO main = do (tempFile, tempHandle) \u003c- openTempFile \".\" \"temp\" ... hClose tempHandle ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:2:7","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"路径操作 相关函数都包含在 System.Directory 模块中. ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:3:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"getCurrentDirectory $$getCurrentDirectory :: IO FilePath$$ 直接返回一个 I/O action，其内容是一个字符串表示当前路径的绝对路径 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:3:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"removeFile $$removeFile :: FilePath \\to IO ()$$ 输入一个文件路径，并删除掉它 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:3:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"renameFile $$renameFile :: FilePath \\to FilePath \\to IO ()$$ 输入一个原路径，一个新路径，为原路径的文件重命名为新路径的名 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:3:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"doesFileExist $$doesFileExist :: FilePath \\to IO Bool$$ 检查文件是否存在，返回一个包含布尔值的 I/O action ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:3:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"Command line arguments System.Environment 模块中提供了两个函数可以用来处理传入命令行的参数 ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:4:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"getArgs $$getArgs :: IO [String]$$ 不需要输入参数，直接返回一个 I/O action，内容为传入命令行的参数（一个由 String 组成的列表）。相当于 C 语言中的 argv[1:] ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:4:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"getProgName $$getProgName :: IO String$$ 返回 I/O action，内容为程序的名字，相当于 C 语言中的 argv[0] ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:4:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"Exceptions 程序在运行失败时会抛出异常，可以通过 Control.Exception 模块中的 catch 函数来捕获异常： $$catch :: Exception e \\Rightarrow IO a \\to (e \\to IO a) \\to IO a$$ 第一个参数是要进行的操作，以 IO a 为返回值的类型，第二个参数是一个函数，它接收异常并进行操作，例如： import Control.Exception main = main' `catch` handler main' :: IO () main' = do ... handler :: Exception e =\u003e e -\u003e IO () handler e = putStrLn \"...\" 也可以利用 guard 语法和 System.IO.Error 中的函数来判断 IO 异常的类型来进行不同操作： import System.Environment import System.IO.Error import Control.Exception main = toTry `catch` handler toTry :: IO () toTry = do (fileName:_) \u003c- getArgs contents \u003c- readFile fileName putStrLn $ \"The file has \" ++ show (length (lines contents)) ++ \" lines!\" handler :: IOError -\u003e IO () handler e | isDoesNotExistError e = putStrLn \"The file doesn't exist!\" | otherwise = ioError e ","date":"2022-03-04","objectID":"https://allen191819.xyz/haskell-3/:5:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记四","uri":"https://allen191819.xyz/haskell-3/"},{"categories":["Haskell"],"content":"Haskell 类型与类型类","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Types \u0026 Typeclasses Haskell Learning ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:0:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Types \u0026 Typeclasses ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:1:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Type Haskell 是 Static Type 的，在编译时期每个表达式的值就已经确定，提高了代码的安全性，同时 Haskell 支持类型推导。 Type Description Int 整型：-2147483648 ～ 2147483647 Integer 无界整型，但效率不及 Int Float 单精度浮点数 Double 双精度浮点数 Bool 布尔值 Char 字符 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:1:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Typeclasses Typeclasses Description Eq 包含可判断相等性的型别。 Qrd 包含可以比较大小的型别 Show 可用字串表示的型别 Read 与 Show 相反的 Typeclass Enum 连续型别-可枚举 Bounded 有上下限的 Typeclass Num 数字的 Typeclass Integral Int Integer Floating Float Double ghci\u003e :t fromIntegral fromIntegral :: (Num b, Integral a) =\u003e a -\u003e b formIntegral 取一个整数做参数并回传一个更加通用的数字，这在同时处理整数和浮点时会尤为有用。 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:1:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"定义新的 Type 和 Typeclass ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Algebraic Data Types Bool 类型的定义 data Bool = False | True data 表示我们要定义一个新的型别。= 的左端标明型别的名称即 Bool，= 的右端就是值构造子 (Value Constructor)，它们明确了该型别可能的值。| 读作\"或\"，所以可以这样阅读该声明：Bool 型别的值可以是 True 或 False。型别名和值构造子的首字母必大写。 值构造子也是函数，可以附带参数，叫做项 field： data Shape = Circle Float Float Float | Rectangle Float Float Float Float 定义了一个新 Type 叫 Shape，值构造器是 Circle 和 Rectangle，Circle 接收三个参数都是 Float 类型，Rectangle 接收四个 Float 类型参数。 对于 Circle： $$Circle :: Float \\to Float \\to Float \\to Shape$$ 如果像使用 show 将它显示出来，则需要将它加入 Show 类型类。需要在代码中加入 deriving (Show): data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show) ** 导出一个 Type** 在文件中定义了新的 Type 之后，如果在别的文件中将其作为模块导入，则需要先导出。比如文件 Shapes.hs 中定义了 Shape 和 Point，以及其他的一些函数，那么文件开头需要写： module Shapes ( Shape(..) , Point(..) , functionA , functionB ) where 其中的 Shape(..) 导出了 Shape 类型和它所有的值构造器，..代表了它的所有值构造器。因此，Shape(..)相当于Shape (Circle, Rectangle)。 如果不想要导出值构造器，即不允许使用值构造器的方法来创建Shape类型的变量。那么需要将Shape(..)替换为Shape，这样就只导出了Shape类型，而不导出其值构造器。 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Record Syntax data Person = Person { firstName :: String , lastName :: String , age :: Int , height :: Float , phoneNumber :: String , flavor :: String } deriving (Show) 调用时： Prelude\u003e let person = Person {firstName = \"Allen\",lastName = \"Ma\",age = 18, height = 178.0, phoneNumber =\"1008611\",flavor = \"Haskell\"} Prelude\u003e person Person {firstName = \"Allen\", lastName = \"Ma\", age = 18, height = 178.0, phoneNumber = \"1008611\", flavor = \"Haskell\"} Prelude\u003e lastName person \"Ma\" Prelude\u003e age person 18 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Type parameters 值构造器可以接收参数，类型也可以接收参数，这样它就成为了类型构造器（type constructors）。如 Maybe 的定义： data Maybe a = Nothing | Just a 它的值是 Nothing 时，类型为 Maybe a，是多态的（polymorphic）。 他的值不是 Nothing 时，类型取决于值 Just a 中 a 的类型，可以构造出 Maybe Int、Maybe [Char]等多种类型： Nothing :: Maybe a Just 1 :: Num a =\u003e Maybe a Just 'a' :: Maybe Char Just \"abc\" :: Maybe [Char] Either Either 是一个类型构造器，它有两个值构造器，定义是： data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show) 如果使用了 Left，那它的 a 的类型就是具体的；如果使用了 Right，那它的 b 的类型就是具体的： ghci\u003e Right 20 Right 20 ghci\u003e Left \"w00t\" Left \"w00t\" ghci\u003e :t Right 'a' Right 'a' :: Either a Char ghci\u003e :t Left True Left True :: Either Bool b Either 可以看作 Maybe 的补充，比如 Maybe 在使用时，出现异常可以返回 Nothing，但只是一个 Nothing，不包含任何信息；但 Either 包含左值和右值，正常结果返回右值，而出现异常就可以返回包含错误信息的左值. safeDiv :: Int -\u003e Int -\u003e Maybe Int safeDiv _ 0 = Nothing safeDiv x y = Just (x `div` y) ghci\u003e safeDiv 4 2 Just 2 ghci\u003e safeDiv 1 0 Nothing safeDiv :: Int -\u003e Int -\u003e Either String Int safeDiv _ 0 = Left \"Divided by zero\" safeDiv x y = Right (x `div` y) ghci\u003e safeDiv 4 2 Right 2 ghci\u003e safeDiv 1 0 Left \"Divided by zero\" ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Derived instances 想要使一个定义的类满足某些 Typeclass 的需求，需要从其派生（derive），比如： data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday deriving (Eq, Ord, Show, Read, Bounded, Enum) 这样 Day 类型的值（Monday ～ Sunday）之间就可以比较是否相等（从 Eq 派生），比较大小（从 Ord 派生，左侧为小，右侧为大），显示成字符串（从 Show 派生），从字符串中读取（从 Read 派生），包含边界（从 Bounded 派生），可以枚举（从 Enum 派生，按照值构造器中的顺序依次向右） ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Type synonyms 为了阅读方便，书写简便，可以使用 type 关键字为已有类型创建别名（synonyms）。比如 String 的定义： type String = [Char] 在所有需要使用字符串（即[Char]）的地方都可以使用 String 来代替，它们是完全一致的，只是 String 更简便易读。 同时，类型别名也可以接收类型参数 newtype keyword 除了data、type关键字之外，还可以用newtype关键字来定义一个新的类型，比如Control.Applicative模块中的ZipList： newtype ZipList a = { getZipList :: [a] } 不同于type，它不是别名，可以使用record语法来直接定义取出值的函数 不同于data，它只能有一个值构造器，但是速度要比data快，而且更加懒惰 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:5","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Recursive data structures 一个类型可以进行递归定义 data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq) ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:6","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"定义新的 Typeclass 定义一个新的 Typeclass 需要使用 class 关键字，例如Eq类型类： class Eq a where (==) :: a -\u003e a -\u003e Bool (/=) :: a -\u003e a -\u003e Bool x == y = not (x /= y) x /= y = not (x == y) 其中 a 是一个类型变量，前两行声明了需要实现的函数的名字及其类型，后两行表明了需要的函数之间可以相互定义（不必要）。 包含了后两行之后，只定义(==)函数或者(/=)函数都可以完成全部定义，它们((==) | (/=))成为这个类型类的最小完整定义（minimal complete definition） 查看一个类型类的成员需要实现的函数可以在 GHCi 中使用:info： ghci\u003e :info Eq 创建实例 是一个类型成为一个类型类实例可以通过 deriving 来自动完成，也可以通过使用 instance 关键字来手动完成，比如使 Point 成为是 Show 的实例： instance Show Point where show (Point x y) = \"(\" ++ show x ++ \", \" ++ show y ++ \")\" -- in ghci ghci\u003e Point 1.0 2.0 (1.0, 2.0) 这样就可以自定义显示的内容，否则使用 deriving 的话只会直接将其转化为字符串。 同时也要注意类型和类型构造器的区别，传入给 instance 的第二个参数应该为类型而不是类型构造器，比如 Maybe： instance Eq Maybe where ... -- 错误用法，因为Maybe是类型构造器而不是类型 instance Eq (Maybe m) where ... -- 错误用法，因为m不一定是Eq的成员 instance (Eq m) =\u003e Eq (Maybe m) where Just x == Just y = x == y Nothing == Nothing = True _ == _ = False 我们使用 haskell 定义一个我们自己的 list : data MyList t = EmptyList | ListNode t (MyList t) 官方的 Haskell 列表定义是这样的：data [] a = [] | a : [a] sum :: (MyList Integer) -\u003e Integer sum EmptyList = 0 sum (ListNode first rest) = first + (sum rest) data MyList t = EmptyList | ListNode t (MyList t) appendRight :: MyList t -\u003e t -\u003e MyList t appendRight EmptyList element = (ListNode element EmptyList) appendRight (ListNode first rest) element = ListNode first (appendRight rest element) Mylist data MyList t = EmptyList | ListNode t (MyList t) deriving (Show) listt = ListNode 7 (ListNode 3 (ListNode 5 (ListNode 8 EmptyList))) isEmpty :: MyList a -\u003e Bool isEmpty EmptyList = True isEmpty _ = False take'' :: Int -\u003e MyList a -\u003e MyList a take'' n _ | n \u003c= 0 = EmptyList take'' _ EmptyList = EmptyList take'' n (ListNode first rest) = ListNode first (take'' (n -1) rest) repeat' :: a -\u003e MyList a repeat' x = ListNode x (repeat' x) sum' :: (Num a) =\u003e MyList a -\u003e a sum' EmptyList = 0 sum' (ListNode first rest) = first + sum' rest product' :: (Num a) =\u003e MyList a -\u003e a product' EmptyList = 0 product' (ListNode first rest) = first * product' rest appendRight :: a -\u003e MyList a -\u003e MyList a appendRight element EmptyList = ListNode element EmptyList appendRight element (ListNode first rest) = ListNode first (appendRight element rest) appendLeft :: a -\u003e MyList a -\u003e MyList a appendLeft = ListNode filter'' :: (a -\u003e Bool) -\u003e MyList a -\u003e MyList a filter'' _ EmptyList = EmptyList filter'' judge (ListNode first rest) | judge first = ListNode first (filter'' judge rest) | otherwise = filter'' judge rest zipWith'' :: (a -\u003e a -\u003e a) -\u003e MyList a -\u003e MyList a -\u003e MyList a zipWith'' _ EmptyList _ = EmptyList zipWith'' _ _ EmptyList = EmptyList zipWith'' func (ListNode first1 rest1) (ListNode first2 rest2) = ListNode (func first1 first2) (zipWith'' func rest1 rest2) addList :: MyList a -\u003e MyList a -\u003e MyList a addList l EmptyList = l addList EmptyList l = l addList l1 (ListNode first rest) = addList (appendRight first l1) rest quickSort :: (Ord a) =\u003e MyList a -\u003e MyList a quickSort EmptyList = EmptyList quickSort (ListNode first rest) = let small = quickSort (filter'' (\u003c= first) rest) big = quickSort (filter'' (\u003e first) rest) in small `addList` (ListNode first EmptyList) `addList` big createList :: [t] -\u003e MyList t createList [] = EmptyList createList (x : xs) = ListNode x $ createList xs list1 = createList [2, 4, 1, 0, 7, 4] main = do print list1 print $ quickSort list1 Functor Typeclass class Functor f where fmap :: (a -\u003e b) -\u003e f a -\u003e f b 其中 f 是一个类型构造器，而不是一个具体类型 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:2:7","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Kind 一个值的类型叫做类型 Type ，而一个类型的类型叫做 Kind。可以通过 GHCi 中 :k 来查看 Kind： ghci\u003e :k Int Int :: * ghci\u003e :k Maybe Maybe :: * -\u003e * ghci\u003e :k Maybe Int Maybe Int :: * ghci\u003e :k Either Either :: * -\u003e * -\u003e * 其中的星号 * 代表了一个具体类型（concrete type）。Int 本身就是一个具体类型，所以 Int 的 Kind 是 *。而 Maybe 是一个类型构造器，它接收一个具体类型返回一个新的具体类型，所以 Maybe 的 Kind 是 *-\u003e*。如果给 Maybe 传入了一个 Int，那么得到的 Maybe Int 就是一个具体的类型，它的 Kind 就是 *。Either 也是一个类型构造器，但它接收两个类型才产生一个新的类型，所以 Either 的 Kind 是 * -\u003e * -\u003e *。 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-2/:3:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记三","uri":"https://allen191819.xyz/haskell-2/"},{"categories":["Haskell"],"content":"Haskell 高阶函数与模块","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"高阶函数与模块 Haskell Learning ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:0:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"高阶函数 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"Curried function Haskell 中的所有函数都只有一个参数，所有多参数函数都是 Curried function(柯里化的函数)，例如一个二元函数 f x y，执行时，他首先会回传一个取一个参数的函数 f x， 再用参数 y 调用它。 $$max :: Ord a \\Rightarrow a \\to a \\to a$$ ghci\u003e max 4 5 5 ghci\u003e (max 4) 5 5 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"高阶函数 Haskell 中的函数可以取另一个函数作为参数，也可以传回函数。 applyTwice ::(a-\u003ea) -\u003e a -\u003e a applyTwice f x = f (f x) 该函数会连续调用两次 f 函数 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"一些高阶函数 zipWith $$zipWith :: (a \\to b \\to c) \\to [a] \\to [b] \\to [c]$$ 第一个参数为一个函数，然后接收两个列表，将其对应元素传入接收的函数中，得到的结果组成一个新的列表。如果两个传入的列表长度不同，以最短的列表为准，长列表中超出的元素省略。用例： ghci\u003e zipWith (*) [1,4,3,7] [1,7,3,4,7] [1,28,9,28] flip $$flip :: (a \\to b \\to c) \\to b \\to a \\to c$$ flip 函数接收一个二元函数，返回一个新的二元函数，将其输入的两个参数顺序反过来： ghci\u003e zip [1,2,3,4,5] \"hello\" [(1,'h'),(2,'e'),(3,'l'),(4,'l'),(5,'o')] ghci\u003e flip zip [1,2,3,4,5] \"hello\" [('h',1),('e',2),('l',3),('l',4),('o',5)] map $$map :: (a \\to b) \\to [a] \\to [b]$$ map 函数接收一个函数 f 和一个列表 a，将函数 f 应用在列表 a 的每个元素中，并返回得到的所有结果组成的列表 b： map (max 6) [1,3,4,9,12] [6,6,6,9,12] filter $$filter :: (a \\to Bool) \\to [a] \\to [a]$$ filter 函数接收一个函数 f 和一个列表 a，将列表 a 中的每个元素传入函数 f 中，如果结果为 True 就保留，结果为 False 就抛弃，返回所有保留的元素组成的新列表： ghci\u003e filter even [1..10] [2,4,6,8,10] takeWhile $$takeWhile :: (a \\to Bool) \\to [a] \\to [a]$$ takeWhile 函数接收一个函数 f 和一个列表 a，将列表 a 中从左向右每个元素传入函数 f，直到结果为 False 停止，返回停止前传入的所有元素组成的新列表： ghci\u003e takeWhile (/=' ') \"word1 word2\" \"word1\" ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"Function application 函数应用可以使用$，$是一个函数，它的类型是： $$($) :: (a \\to b) \\to a \\to b$$ 它可以改变函数结合优先级，将左侧函数应用于全部右侧内容上，相当于给右侧整体加上了括号。否则函数默认左结合，会依次向右应用而不会应用在整体上。 f $ g x -- 等价于 f (g x) ----- f g x -- 等价于 (f g) x ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"Function Composition 函数复合可以使用.，.也是一个函数，它的类型是： $$(.) :: (b \\to c) \\to (a \\to b) \\to a \\to c$$ 定义是： $$ f . g = \\x \\to f (g x) $$ 但是函数复合的优先级要比函数执行低，比如： sum . replicate 5 . max 6.7 8.9 会先执行 max 6.7 8.9 并返回 8.9，然后将 sum、replicate 5、8.9 复合，但两个函数无法和一个值(8.9)复合，所以会抛出异常。因此要使用$来规定先复合再执行： sum . replicate 5 . max 6.7 $ 8.9 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:5","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"lambda λ lambda 就是匿名函数。有些时候我们需要传给高阶函数一个函数，而这函数我们只会用这一次，这就弄个特定功能的 lambda。编写 lambda，就写个 \\ (因为它看起来像是希腊字母的 λ ? 其实我觉得一点都不像)，后面是用空格分隔的参数，$\\to$ 后面就是函数体。通常我们都是用括号将其括起，要不然它就会占据整个右边部分。 \\para1 para2 ... -\u003e return ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:1:6","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"Modules Haskell 会自动加载 Prelude 模块（module），如果在 GHCi 中再加载其他模块，需要使用:m + …，比如加载 Data.List 模块： Prelude\u003e :m + Data.List 而在 hs 文件中引入模块，需要使用 import 语句: import Data.List import Data.List (nub, sort) -- 仅 import nub sort 函数 import Data.List hiding (nub) -- 不 improt nub 函数 import qualified Data.List import qualified Data.List as Li ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:2:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"编写自己的 Modules 模块中要包含将要使用的一些函数，像正常的 hs 文件一样写即可，但头部需要有导出语句（export）。比如一个模块文件名叫Geometry.hs： module Geometry ( sphereVolume , sphereArea , cubeVolume , cubeArea , cuboidArea , cuboidVolume ) where sphereVolume :: Float -\u003e Float sphereVolume radius = (4.0 / 3.0) * pi * (radius ^ 3) sphereArea :: Float -\u003e Float sphereArea radius = 4 * pi * (radius ^ 2) cubeVolume :: Float -\u003e Float cubeVolume side = cuboidVolume side side side cubeArea :: Float -\u003e Float cubeArea side = cuboidArea side side side cuboidVolume :: Float -\u003e Float -\u003e Float -\u003e Float cuboidVolume a b c = rectangleArea a b * c cuboidArea :: Float -\u003e Float -\u003e Float -\u003e Float cuboidArea a b c = rectangleArea a b * 2 + rectangleArea a c * 2 + rectangleArea c b * 2 rectangleArea :: Float -\u003e Float -\u003e Float rectangleArea a b = a * b 在调用该模块时，只能调用module Geometry(...) 中包含的内容，其他不在其中的函数都不调用。 ","date":"2022-03-03","objectID":"https://allen191819.xyz/haskell-1/:2:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记二","uri":"https://allen191819.xyz/haskell-1/"},{"categories":["Haskell"],"content":"Haskell 基础语法","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Haskell 基础语法 Haskell Learning ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:0:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Functional Programming Pure functions Immutable Data No/Less side-effects Declatative Easier to verity ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:1:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"基础语法 ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:2:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"基础运算 Char Function + - \\* / 加减乘除 div 整除 mod 取模 True Flase Boolean || \u0026\u0026 not 或且非 == 条件判断 相等 \\\\= 条件判断 不相等 ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:2:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"函数调用 ghci\u003e max 1 2 2 中缀函数与前缀函数的转换(prefix \u0026 infix) 对前缀函数加``使其变成中缀函数 对中缀函数加()使其变成前缀函数 ghci\u003e 4 `div` 2 2 ghci\u003e 1 `max` 2 2 ghci\u003e (+) 1 2 3 ghci\u003e (||) True False True ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:2:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"List List 常用函数 (++) :: [a] -\u003e [a] -\u003e [a]：合并两个列表 (:) :: a -\u003e [a] -\u003e [a]：将单个元素并入列表。[1, 2, 3]是 1:2:3:[]的语法糖 (!!) :: [a] -\u003e Int -\u003e a：通过索引取出某个位置上的元素。a !! 1 相当于 Python 中的 a[1] head :: [a] -\u003e a：返回列表的第一个元素 tail :: [a] -\u003e [a]：返回列表中除去第一个元素后的列表（若只有一个元素则返回空列表 ） last :: [a] -\u003e a：返回列表中的最后一个元素 init :: [a] -\u003e [a]：返回列表中除去最后一个元素后的列表 length :: Foldable t =\u003e t a -\u003e Int：返回列表的长度 null :: Foldable t =\u003e t a -\u003e Bool：返回列表是否为空 reverse :: [a] -\u003e [a]：返回翻转后的列表 take :: Int -\u003e [a] -\u003e [a]：返回列表 a 的前 n 个元素的列表(take n a) drop :: Int -\u003e [a] -\u003e [a]：返回列表 a 中除去前 n 个元素后的列表(drop n a) maximum :: (Foldable t, Ord a) =\u003e t a -\u003e a：返回列表中的最大值 minimum :: (Foldable t, Ord a) =\u003e t a -\u003e a：返回列表中的最小值 sum :: (Foldable t, Num a) =\u003e t a -\u003e a：返回列表中所有元素的和 product :: (Foldable t, Num a) =\u003e t a -\u003e a：返回列表中所有元素的积 elem :: (Foldable t, Eq a) =\u003e t a -\u003e Bool：判断值 n 是否在列表 a 中 Range: .. ghci\u003e [1 .. 10] [1,2,3,4,5,6,7,8,9,10] ghci\u003e ['a' .. 'z'] \"abcdefghijklmnopqrstuvwxyz\" ghci\u003e ['K' .. 'Z'] \"KLMNOPQRSTUVWXYZ\" ghci\u003e [2, 4 .. 20] [2,4,6,8,10,12,14,16,18,20] ghci\u003e [3, 6 .. 20] [3,6,9,12,15,18] ghci\u003e [5, 4 .. 1] [5,4,3,2,1] haskell 是惰性的，生成无穷列表之后通过 take 生成 list: cycle :: [a] -\u003e [a]：将原列表不断循环生成无穷列表 repeat :: a -\u003e [a]：将传入的值不断重复生成无穷列表 replicate :: Int -\u003e a -\u003e [a]：将值 a 重复 n 次，返回生成的列表(replicate n a) ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:2:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"List comprehension ghci\u003e [x * 2 | x \u003c- [1 .. 10]] [2,4,6,8,10,12,14,16,18,20] ghci\u003e [x * 2 | x \u003c- [1 .. 10], x * 2 \u003e= 12] [12,14,16,18,20] ghci\u003e [ x | x \u003c- [50 .. 100], x `mod` 7 == 3] [52,59,66,73,80,87,94] ghci\u003e [x * y | x \u003c- [2, 5, 10], y \u003c- [8, 10, 11]] [16,20,22,40,50,55,80,100,110] ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:2:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Tuple Haskell 中的元组可以有不同的长度，元素类型也可以不同，元组类型由其中的所有元素的类型共同决定。二元元组的常用函数： fst :: (a, b) -\u003e a：返回含有两个元素元组中的第一个元素 snd :: (a, b) -\u003e b：返回含有两个元素元组中的第二个元素 zip :: [a] -\u003e [b] -\u003e [(a, b)]：接收两个列表，返回一个列表，每个元素是依次将两个列表中元素配对成的二元组 ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:2:5","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Syntax in Functions ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:3:0","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"定义函数 直接定义一个函数： add' x y = x + y 这时 Haskell 会自动推断函数的类型为(Num a) =\u003e a -\u003e a -\u003e a。但是最好在定义函数前声明函数的类型： add' :: (Num a)=\u003ea-\u003ea-\u003ea add' x y = x + y ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:3:1","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Pattern matching luckyNumber :: (Integral a)=\u003ea-\u003eString luckyNumber 6 = \"Lucky number six!\" luckyNumber x = \"Sorry, you're out of luck.\" 注意：在定义模式时，一定要留一个万能匹配的模式，这样我们的进程就不会为了不可预料的输入而崩溃了。 (x:xs) 模式 sum' :: (Num a) =\u003e [a] -\u003e a sum' [] = 0 sum' (x:xs) = x + sum' xs as 模式:将一个名字和 @ 置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。 capital :: String -\u003e String capital \"\" = \"Empty string, whoops!\" capital all@(x:xs) = \"The first letter of \" ++ all ++ \" is \" ++ [x] ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:3:2","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Guards Compare :: (Ord a) =\u003e a -\u003e a -\u003e Ordering a `Compare` b | a \u003e b = GT | a == b = EQ | otherwise = LT ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:3:3","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"关键字 where 和 let bmiTell :: (RealFloat a) =\u003e a -\u003e a -\u003e String bmiTell weight height | bmi \u003c= 18.5 = \"You're underweight\" | bmi \u003c= 25.0 = \"You're supposedly normal.\" | bmi \u003c= 30.0 = \"You're fat!\" | otherwise = \"You're a whale!\" where bmi = weight / height ^ 2 quicksort :: (Ord a) =\u003e [a] -\u003e [a] quicksort [] = [] quicksort (x : xs) = let smallerSorted = quicksort [a | a \u003c- xs, a \u003c= x] biggerSorted = quicksort [a | a \u003c- xs, a \u003e x] in smallerSorted ++ [x] ++ biggerSorted ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:3:4","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Haskell"],"content":"Case expressions describeList :: [a] -\u003e String describeList xs = \"The list is \" ++ case xs of [] -\u003e \"empty.\" [x] -\u003e \"a singleton list.\" xs -\u003e \"a longer list.\" case expression of pattern -\u003e result pattern -\u003e result pattern -\u003e result ... ","date":"2022-03-02","objectID":"https://allen191819.xyz/haskell/:3:5","tags":["Lambda","FP"],"title":"Haskell 学习笔记一","uri":"https://allen191819.xyz/haskell/"},{"categories":["Latex"],"content":"Latex 符号速查","date":"2022-02-27","objectID":"https://allen191819.xyz/latexsymbols/","tags":["Latex","Cheetsheet"],"title":"Latex Symbols","uri":"https://allen191819.xyz/latexsymbols/"},{"categories":["Latex"],"content":"Latex 属性符号速查 ","date":"2022-02-27","objectID":"https://allen191819.xyz/latexsymbols/:0:0","tags":["Latex","Cheetsheet"],"title":"Latex Symbols","uri":"https://allen191819.xyz/latexsymbols/"},{"categories":["Dataset"],"content":"Celeba 数据集介绍","date":"2021-12-12","objectID":"https://allen191819.xyz/celeba/","tags":["AI"],"title":"Celeba 数据集","uri":"https://allen191819.xyz/celeba/"},{"categories":["Dataset"],"content":"对于 Celeba 数据集的介绍 Celeba 数据集 CelebA是CelebFaces Attribute的缩写，意即名人人脸属性数据集，其包含10,177个名人身份的202,599张人脸图片，每张图片都做好了特征标记，包含人脸bbox标注框、5个人脸特征点坐标以及40个属性标记，CelebA由香港中文大学开放提供，广泛用于人脸相关的计算机视觉训练任务，可用于人脸属性标识训练、人脸检测训练以及landmark(特征点)标记等，官方网址：Large-scale CelebFaces Attributes (CelebA) Dataset ","date":"2021-12-12","objectID":"https://allen191819.xyz/celeba/:0:0","tags":["AI"],"title":"Celeba 数据集","uri":"https://allen191819.xyz/celeba/"},{"categories":["Dataset"],"content":"几种下载的资源 In-The-Wild Images (Img/img_celeba.7z) 202,599张原始“野生”人脸图像，从网络爬取未有做任何裁剪缩放操作的人脸图像； Align\u0026Cropped Images (Img/img_align_celeba.zip \u0026 Img/img_align_celeba_png.7z) 202,599张经过人脸对齐和裁剪了的图像，视情况下载对应不同质量的图像即可，一般选择jpg格式才1G多的img_align_celeba.zip文件； ","date":"2021-12-12","objectID":"https://allen191819.xyz/celeba/:1:0","tags":["AI"],"title":"Celeba 数据集","uri":"https://allen191819.xyz/celeba/"},{"categories":["Dataset"],"content":"几种分类标签 Bounding Box Annotations (Anno/list_bbox_celeba.txt) bounding box标签，即人脸标注框坐标注释文件，包含每一张图片对应的bbox起点坐标及其宽高，如下： 202599 image_id x_1 y_1 width height 000001.jpg 95 71 226 313 000002.jpg 72 94 221 306 000003.jpg 216 59 91 126 000004.jpg 622 257 564 781 000005.jpg 236 109 120 166 000006.jpg 146 67 182 252 000007.jpg 64 93 211 292 000008.jpg 212 89 218 302 000009.jpg 600 274 343 475 000010.jpg 113 110 211 292 000011.jpg 166 68 125 173 000012.jpg 102 31 104 144 Landmarks Annotations (Anno/list_landmarks_celeba.txt \u0026 Anno/list_landmarks_align_celeba.txt) 5个特征点landmark坐标注释文件，list_landmarks_align_celeba.txt则是对应人脸对齐后 的landmark坐标 202599 lefteye_x lefteye_y righteye_x righteye_y nose_x nose_y leftmouth_x leftmouth_y rightmouth_x rightmouth_y 000001.jpg 69 109 106 113 77 142 73 152 108 154 000002.jpg 69 110 107 112 81 135 70 151 108 153 000003.jpg 76 112 104 106 108 128 74 156 98 158 000004.jpg 72 113 108 108 101 138 71 155 101 151 000005.jpg 66 114 112 112 86 119 71 147 104 150 000006.jpg 71 111 106 110 94 131 74 154 102 153 000007.jpg 70 112 108 111 85 135 72 152 104 152 000008.jpg 71 110 106 111 84 137 73 155 104 153 Attributes Annotations (Anno/list_attr_celeba.txt) 40个属性标签文件，第一行为图像张数，第二行为属性名，有该属性则标记为1，否则标记为-1 202599 5_o_Clock_Shadow Arched_Eyebrows Attractive Bags_Under_Eyes Bald Bangs Big_Lips Big_Nose Black_Hair Blond_Hair Blurry Brown_Hair Bushy_Eyebrows Chubby Double_Chin Eyeglasses Goatee Gray_Hair Heavy_Makeup High_Cheekbones Male Mouth_Slightly_Open Mustache Narrow_Eyes No_Beard Oval_Face Pale_Skin Pointy_Nose Receding_Hairline Rosy_Cheeks Sideburns Smiling Straight_Hair Wavy_Hair Wearing_Earrings Wearing_Hat Wearing_Lipstick Wearing_Necklace Wearing_Necktie Young 000001.jpg -1 1 1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 1 1 -1 1 -1 -1 1 -1 -1 1 -1 -1 -1 1 1 -1 1 -1 1 -1 -1 1 000002.jpg -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 1 -1 1 -1 -1 1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 1 000003.jpg -1 -1 -1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 1 1 -1 -1 1 -1 -1 -1 -1 -1 1 -1 -1 -1 -1 -1 1 000004.jpg -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 1 -1 -1 -1 -1 1 -1 1 -1 1 1 -1 1 000005.jpg -1 1 1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 -1 1 1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 1 000006.jpg -1 1 1 -1 -1 -1 1 -1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 1 -1 -1 1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 -1 1 1 -1 1 -1 -1 1 000007.jpg 1 -1 1 1 -1 -1 1 1 1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 -1 1 -1 -1 -1 1 -1 -1 1 -1 -1 -1 -1 1 -1 -1 -1 -1 -1 -1 1 Identity Annotations (available upon request) 10,177个名人身份标识，图片的序号即是该图片对应的标签 000001.jpg 2880 000002.jpg 2937 000003.jpg 8692 000004.jpg 5805 000005.jpg 9295 000006.jpg 4153 000007.jpg 9040 000008.jpg 6369 000009.jpg 3332 000010.jpg 612 000011.jpg 2807 000012.jpg 7779 000013.jpg 3785 000014.jpg 7081 000015.jpg 1854 000016.jpg 4905 000017.jpg 667 000018.jpg 2464 000019.jpg 2929 000020.jpg 2782 000021.jpg 181 000022.jpg 6642 Evaluation Partitions (Eval/list_eval_partition.txt) 用于划分为training，validation及testing等数据集的标签文件，标签0对应training，标签1对应validation，标签2对应testing ","date":"2021-12-12","objectID":"https://allen191819.xyz/celeba/:2:0","tags":["AI"],"title":"Celeba 数据集","uri":"https://allen191819.xyz/celeba/"},{"categories":["Markdown"],"content":"对 mermaid 的介绍","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"借助 mermaid 在 markdown 中嵌入图表 Mermaid learn ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:0:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"Mermaid 可以绘制的图表类型 饼状图：使用 pie 关键字，具体用法后文将详细介绍 流程图：使用 graph 关键字，具体用法后文将详细介绍 序列图：使用 sequenceDiagram 关键字 甘特图：使用 gantt 关键字 类图：使用 classDiagram 关键字 状态图：使用 stateDiagram 关键字 用户旅程图：使用 journey 关键字 一个例子Archlinux yyds graph TD A[Choosing an OS] --\u003e B{Do you fear technology ?} B --\u003e|Yes| C{Is your daddy rich ?} C --\u003e|Yes| E(fa:fa-apple Mac OS); C --\u003e|No| F(fa:fa-chrome Chrome OS); B --\u003e|No| D{Do you care about freedom/privacy ?} D --\u003e|Yes| G{Do you have a life ?} D --\u003e|No| H(fa:fa-windows Windows); G --\u003e|Yes| I(fa:fa-ubuntu Ubuntu); G --\u003e|Yes| K(fa:fa-fedora Fedora); G --\u003e|No| L(fa:fa-linux Archlinux); G --\u003e|No| M(fa:fa-shield Backtrack); style A fill:#0094FF,stroke:#333,stroke-width:4px,color:#fff style E fill:#808080,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style F fill:#808080,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style H fill:#004A7F,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style I fill:#FF6A00,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style K fill:#FF6A00,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style L fill:#7F0000,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 style M fill:#7F0000,stroke:#333,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:1:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"流程图 graph TD A[Hard] --\u003e|Text| B(Round) B --\u003e C{Decision} C --\u003e|One| D[Result 1] C --\u003e|Two| E[Result 2] doc ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:2:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"时序图 sequenceDiagram Alice-\u003e\u003eJohn: Hello John, how are you? loop Healthcheck John-\u003e\u003eJohn: Fight against hypochondria end Note right of John: Rational thoughts! John--\u003e\u003eAlice: Great! John-\u003e\u003eBob: How about you? Bob--\u003e\u003eJohn: Jolly good! doc ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:3:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"甘特图 gantt section Section Completed :done, des1, 2014-01-06,2014-01-08 Active :active, des2, 2014-01-07, 3d Parallel 1 : des3, after des1, 1d Parallel 2 : des4, after des1, 1d Parallel 3 : des5, after des3, 1d Parallel 4 : des6, after des4, 1d doc ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:4:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"类图 classDiagram Animal \u003c|-- Duck Animal \u003c|-- Fish Animal \u003c|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck{ +String beakColor +swim() +quack() } class Fish{ -int sizeInFeet -canEat() } class Zebra{ +bool is_wild +run() } doc ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:5:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"状态图 stateDiagram-v2 [*] --\u003e Still Still --\u003e [*] Still --\u003e Moving Moving --\u003e Still Moving --\u003e Crash Crash --\u003e [*] doc ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:6:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Markdown"],"content":"饼状图 pie title 为什么不喜欢出门 \"懒\" : 50 \"社恐\" : 40 \"穷\" : 200 ","date":"2021-12-04","objectID":"https://allen191819.xyz/mermaid/:7:0","tags":["Daily study","Markdown"],"title":"Markdown 嵌入关系图表","uri":"https://allen191819.xyz/mermaid/"},{"categories":["Backdoor Attack"],"content":"对于 Hidden trigger backdoor attack 的复现","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"对于 Hidden trigger backdoor attack 的复现 Backdoor attack 主要工作以及算法 二分类 代码实现 生成毒化样本 猴子数据集 target data source data patched data posion data patched result clean result 猫狗大战 target image source data patched data posion data patched result 准确率 73% clean result 准确率 94% 多分类 backdoor(Cifar10) 未贴 patch 的数据 贴 patch 后的数据 目标类别 毒化数据 实验结果 不同影响因素分析 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:0:0","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"主要工作以及算法 对于给出的 $target$ 图像 $t$ ， $source$ 图像 $s$ ， 以及 $trigger\\ patch\\ p$ ， 将 $p$ 贴在 $s$ 上得到一个 $\\tilde s$ 。 通过如下方法获得毒化数据 $z$ : $$ arg_{z}\\ min ||f(z)-f(\\tilde s)||_{2}^{2} $$ $$ st.\\ |z-t|_{\\infty} \u003c \\epsilon $$ 生成毒化数据的具体算法 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:1:0","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"二分类 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:2:0","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"代码实现 获取 fc7 的特征输出 主要通过添加钩子 feat1 获取网络 forward 过程中的 fc7 获取的特征 import torch import torch.nn as nn from torch.utils.model_zoo import load_url as load_state_dict_from_url **all** = ['AlexNet', 'alexnet'] model_urls = { 'alexnet': 'https://download.pytorch.org/models/alexnet-owt-4df8aa71.pth', } class NormalizeByChannelMeanStd(nn.Module): def **init**(self, mean, std): super(NormalizeByChannelMeanStd, self).**init**() if not isinstance(mean, torch.Tensor): mean = torch.tensor(mean) if not isinstance(std, torch.Tensor): std = torch.tensor(std) self.register_buffer(\"mean\", mean) self.register_buffer(\"std\", std) def forward(self, tensor): return normalize_fn(tensor, self.mean, self.std) def extra_repr(self): return 'mean={}, std={}'.format(self.mean, self.std) def normalize_fn(tensor, mean, std): \"\"\"Differentiable version of torchvision.functional.normalize\"\"\" mean = mean[None, :, None, None] std = std[None, :, None, None] return tensor.sub(mean).div(std) class AlexNet(nn.Module): def **init**(self, num_classes=1000): super(AlexNet, self).**init**() self.features = nn.Sequential( nn.Conv2d(3, 64, kernel_size=11, stride=4, padding=2), nn.ReLU(inplace=True), nn.MaxPool2d(kernel_size=3, stride=2), nn.Conv2d(64, 192, kernel_size=5, padding=2), nn.ReLU(inplace=True), nn.MaxPool2d(kernel_size=3, stride=2), nn.Conv2d(192, 384, kernel_size=3, padding=1), nn.ReLU(inplace=True), nn.Conv2d(384, 256, kernel_size=3, padding=1), nn.ReLU(inplace=True), nn.Conv2d(256, 256, kernel_size=3, padding=1), nn.ReLU(inplace=True), nn.MaxPool2d(kernel_size=3, stride=2), ) self.avgpool = nn.AdaptiveAvgPool2d((6, 6)) self.classifier = nn.Sequential( nn.Dropout(), nn.Linear(256 _ 6 _ 6, 4096), nn.ReLU(inplace=True), nn.Dropout(), nn.Linear(4096, 4096), nn.ReLU(inplace=True), nn.Linear(4096, num_classes), ) def forward(self, x): x = self.features(x) x = self.avgpool(x) x = x.flatten(1) for i in range(6): x = self.classifier[i](x) feat = x x = self.classifier[6](x) return x, feat def alexnet(pretrained=False, progress=True, **kwargs): model = AlexNet(**kwargs) if pretrained: state_dict = load_state_dict_from_url(model_urls['alexnet'], progress=progress) model.load_state_dict(state_dict) return model ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:2:1","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"生成毒化样本 def train(model, epoch): # AVERAGE METER losses = AverageMeter() # TRIGGER PARAMETERS trans_image = transforms.Compose([ transforms.Resize((224, 224)), transforms.ToTensor(), ]) trans_trigger = transforms.Compose([ transforms.Resize((patch_size, patch_size)), transforms.ToTensor(), ]) eps1 = (eps / 255.0) lr1 = lr trigger = Image.open( './triggers/trigger_{}.png'.format(trigger_id)).convert('RGB') trigger = trans_trigger(trigger).unsqueeze(0).cuda() dataset_target = PoisonGenerationDataset(\"./target/n1\", target_filelist, trans_image) dataset_source = PoisonGenerationDataset('./source/n0', source_filelist, trans_image) train_loader_target = torch.utils.data.DataLoader(dataset_target, batch_size=20, shuffle=True, num_workers=2, pin_memory=True) train_loader_source = torch.utils.data.DataLoader(dataset_source, batch_size=20, shuffle=True, num_workers=2, pin_memory=True) iter_target = iter(train_loader_target) iter_source = iter(train_loader_source) num_poisoned = 0 for i in tqdm(range(len(train_loader_target))): (input1, path1) = next(iter_source) (input2, path2) = next(iter_target) img_ctr = 0 input1 = input1.cuda() input2 = input2.cuda() pert = nn.Parameter( torch.zeros_like(input2, requires_grad=True).cuda()) for z in range(input1.size(0)): if not rand_loc: start_x = 224 - patch_size - 5 start_y = 224 - patch_size - 5 else: start_x = random.randint(0, 224 - patch_size - 1) start_y = random.randint(0, 224 - patch_size - 1) input1[z, :, start_y:start_y + patch_size, start_x:start_x + patch_size] = trigger output1, feat1 = model(input1) feat1 = feat1.detach().clone() for k in range(input1.size(0)): img_ctr = img_ctr + 1 # input2_pert = (pert[k].clone().cpu()) fname = saveDir_patched + '/' + 'badnet_' + str(os.path.basename(path1[k])).split('.')[0] + '_' + 'epoch_' + str(epoch).zfill(2)\\ + str(img_ctr).zfill(5)+'.png' save_image(input1[k].clone().cpu(), fname) num_poisoned += 1 for j in range(num_iter): lr1 = adjust_learning_rate(lr, j) output2, feat2 = model(input2 + pert) feat11 = feat1.clone() dist = torch.cdist(feat1, feat2) for _ in range(feat2.size(0)): dist_min_index = (dist == torch.min(dist)).nonzero( as_tuple=False).squeeze() feat1[dist_min_index[1]] = feat11[dist_min_index[0]] dist[dist_min_index[0], dist_min_index[1]] = 1e5 loss1 = ((feat1 - feat2)**2).sum(dim=1) loss = loss1.sum() losses.update(loss.item(), input1.size(0)) loss.backward() pert = pert - lr1 * pert.grad pert = torch.clamp(pert, -eps1, eps1).detach_() pert = pert + input2 pert = pert.clamp(0, 1) if loss1.max().item() \u003c 10 or j == (num_iter - 1): for k in range(input2.size(0)): img_ctr = img_ctr + 1 input2_pert = (pert[k].clone().cpu()) fname = saveDir_poison + '/' + 'loss_' + str(int(loss1[k].item())).zfill(5) + '_' + 'epoch_' + \\ str(epoch).zfill(2) + '_' + str(os.path.basename(path2[k])).split('.')[0] + '_' + \\ str(os.path.basename(path1[k])).split('.')[0] + '_kk_' + str(img_ctr).zfill(5)+'.png' save_image(input2_pert, fname) num_poisoned += 1 break pert = pert - input2 pert.requires_grad = True ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:2:2","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"猴子数据集 target data source data patched data posion data patched result clean result ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:2:3","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"猫狗大战 target image source data patched data posion data patched result 准确率 73% clean result 准确率 94% ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:2:4","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"多分类 backdoor(Cifar10) 在使用改动后的alexnet网络，并将 Cifar10 划分为两部分，一部分用了预训练：预训练结果：训练集：94%，测试集：66% 识别准确率： class AlexNet(nn.Module): def __init__(self, num_classes=10): super(AlexNet, self).__init__() self.features = nn.Sequential( nn.Conv2d(3, 96, 7, 2, 2), nn.ReLU(inplace=True), nn.MaxPool2d(3, 2, 0), nn.Conv2d(96, 256, 5, 1, 2), nn.ReLU(inplace=True), nn.MaxPool2d(3, 2, 0), nn.Conv2d(256, 384, 3, 1, 1), nn.ReLU(inplace=True), nn.Conv2d(384, 256, 3, 1, 1), nn.ReLU(inplace=True), nn.Conv2d(256, 256, 3, 1, 1), nn.ReLU(inplace=True), ) self.classifier = nn.Sequential( nn.Linear(256 * 3 * 3, 1024), nn.ReLU(inplace=True), nn.Linear(1024, 512), nn.ReLU(inplace=True), nn.Linear(512, num_classes), ) def forward(self, x): x = self.features(x) x = x.view(x.size()[0], -1) for i in range(4): x = self.classifier[i](x) feat = x x = self.classifier[4](x) return x, feat ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:0","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"未贴 patch 的数据 类别一 类别二 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:1","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"贴 patch 后的数据 类别一 类别二 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:2","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"目标类别 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:3","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"毒化数据 类别一 类别二 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:4","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"实验结果 未贴标签 贴标签 ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:5","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Backdoor Attack"],"content":"不同影响因素分析 不同大小的 patch 对攻击结果的影响 patch size 4 6 8 nopatch acc 0.623 0.623 0.621 patched acc 0.595 0.564 0.441 target 0.074 0.075 0.094 不同数据集分割方案对攻击结果的影响(patch size = 6) 预训练/微调 毒化数据 val acc nopatch acc patched acc target 3500/1500 300 0.631 0.595 0.503 0.096 3500/1500 200 0.639 0.617 0.502 0.092 3500/1500 150 0.640 0.623 0.525 0.084 3500/1500 100 0.642 0.626 0.567 0.081 3000/2000 300 0.640 0.602 0.529 0.113 3000/2000 200 0.642 0.611 0.525 0.095 3000/2000 150 0.644 0.609 0.526 0.080 3000/2000 100 0.646 0.610 0.498 0.080 2500/2500 300 0.635 0.623 0.564 0.075 2500/2500 200 0.643 0.634 0.544 0.078 2500/2500 150 0.642 0.636 0.542 0.065 2500/2500 100 0.639 0.624 0.520 0.081 2000/3000 300 0.599 0.569 0.476 0.082 2000/3000 200 0.602 0.573 0.478 0.113 2000/3000 150 0.600 0.580 0.486 0.104 2000/3500 100 0.604 0.573 0.487 0.076 1500/3500 300 0.584 0.566 0.476 0.090 参考文献 Hidden trigger backdoor ","date":"2021-12-04","objectID":"https://allen191819.xyz/backdoor/:3:6","tags":["Daily study","AI security"],"title":"隐秘的后门攻击","uri":"https://allen191819.xyz/backdoor/"},{"categories":["Advesarial Attack"],"content":"对于 Hidden trigger backdoor attack 的复现","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"UAP 生成对抗样本实践(pytorch) UAP 原理与实现 算法思想 算法表述 无目标攻击 有目标攻击 范数约束 UAP 实现 导入模块 超参数 获取 cifar10 数据集 定义网络 创建 simple_model 对象，并可视化网络 训练模型 模型测试 UAP 算法 Attack test Target attack ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:0:0","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"算法思想 对于一个数据点集 $x$ ,希望找到一个向量 $v$ 可以迷惑分类器 $\\hat{k}$ 使得： $$ \\hat{k}(x+v)\\neq \\hat{k}(x) \\ for \\ most \\ x\\backsim \\mu $$ 同时对于这样一个扰动 $v$ 存在约束 $|v| _ p \u003c \\xi$ $P_{x \\backsim \\mu}(\\hat{k}(x+v) \\neq \\hat{k}(x))\\leq 1-\\delta$ 如图所示，通过多次迭代，使用每次迭代获得的 $v_i$ 一步步将 $x$ 数据点从原本三个类别重合的区域分类到 $R_3$ ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:1:0","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"算法表述 ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:2:0","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"无目标攻击 ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:2:1","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"有目标攻击 ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:2:2","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"范数约束 $$limtfunc(dist, epsilon) = dist * min ( 1, \\frac{\\epsilon}{||dist||} )$$ ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:2:3","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"UAP 实现 ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:0","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"导入模块 from **future** import print_function import torch import numpy as np import torch.nn as nn from torchvision import datasets, transforms from tqdm import tqdm from absl import app, flags import torchvision import math import matplotlib.pyplot as plt ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:1","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"超参数 BATCH_SIZE = 10 EPOCH = 5 LEARNING_RATE = 0.001 device = torch.device(\"cuda\" if (torch.cuda.is_available()) else \"cpu\") device(type='cuda') ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:2","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"获取 cifar10 数据集 transform = transforms.Compose([transforms.ToTensor()]) train_dataset = datasets.CIFAR10(root='../data/Cifar10', train=True, transform=transform, download=True) train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=BATCH_SIZE, shuffle=True) test_dataset = datasets.CIFAR10(root='../data/Cifar10', train=False, transform=transform, download=True) test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=BATCH_SIZE, shuffle=True) Files already downloaded and verified Files already downloaded and verified ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:3","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"定义网络 class ResidualBlock(nn.Module): def __init__(self, inchannel, outchannel, stride=1): super(ResidualBlock, self).__init__() # 这里的即为两个3*3 conv self.left = nn.Sequential( nn.Conv2d(inchannel, outchannel, kernel_size=3, stride=stride, padding=1, bias=False), # bias为偏置，False表示不添加偏置 nn.BatchNorm2d(outchannel), nn.ReLU(), nn.Conv2d(outchannel, outchannel, kernel_size=3, stride=1, padding=1, bias=False), nn.BatchNorm2d(outchannel)) self.shortcut = nn.Sequential() # shortcut connections if stride != 1 or inchannel != outchannel: # 判断入通道和出通道是否一样，不一样的话进行卷积操作 self.shortcut = nn.Sequential( nn.Conv2d(inchannel, outchannel, kernel_size=1, stride=stride, bias=False), nn.BatchNorm2d(outchannel)) self.relu = nn.ReLU() def forward(self, x): out = self.left(x) out += self.shortcut(x) out = self.relu(out) return out class Net(nn.Module): def __init__(self, ResidualBlock): super(Net, self).__init__() # 图片处理，也就是白色方框内的3*3 conv self.conv1 = nn.Sequential( nn.Conv2d(3, 64, kernel_size=3, stride=1, padding=1, bias=False), nn.BatchNorm2d(64), nn.ReLU(), ) # 中间的残差网络部分，与图上的结构一一对应 self.layer1 = self.make_layer(ResidualBlock, 64, 64, 2, stride=1) self.layer2 = self.make_layer(ResidualBlock, 64, 128, 2, stride=2) self.layer3 = self.make_layer(ResidualBlock, 128, 256, 2, stride=2) self.layer4 = self.make_layer(ResidualBlock, 256, 512, 2, stride=2) self.avg_pool2d = nn.AvgPool2d(4) self.fc = nn.Linear(512, 10) # 相当于看处理几次，18的是每个处理两次 def make_layer(self, block, inchannel, outchannel, num_blocks, stride): layers = [] for i in range(1, num_blocks): layers.append(block(inchannel, outchannel, stride)) return nn.Sequential(*layers) def forward(self, x): out = self.conv1(x) out = self.layer1(out) out = self.layer2(out) out = self.layer3(out) out = self.layer4(out) out = self.avg_pool2d(out) out = out.view(out.size(0), -1) out = self.fc(out) return out ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:4","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"创建 simple_model 对象，并可视化网络 simple_model = torch.load(\"/home/allen/Workplace/Advesarial-Attack-toturial/UAP/model/simple_model.pkl\") optimizer = torch.optim.Adam(simple_model.parameters(), lr=0.001, betas=(0.9, 0.99)) loss_function = nn.CrossEntropyLoss() print(simple_model) import hiddenlayer as hl hl_graph = hl.build_graph(simple_model, torch.zeros([1,3,32,32]).to(device)) hl_graph.theme = hl.graph.THEMES[\"blue\"].copy() hl_graph Net( (conv1): Sequential( (0): Conv2d(3, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() ) (layer1): Sequential( (0): ResidualBlock( (left): Sequential( (0): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Conv2d(64, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (4): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (shortcut): Sequential() (relu): ReLU() ) ) (layer2): Sequential( (0): ResidualBlock( (left): Sequential( (0): Conv2d(64, 128, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Conv2d(128, 128, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (4): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (shortcut): Sequential( (0): Conv2d(64, 128, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (relu): ReLU() ) ) (layer3): Sequential( (0): ResidualBlock( (left): Sequential( (0): Conv2d(128, 256, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Conv2d(256, 256, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (4): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (shortcut): Sequential( (0): Conv2d(128, 256, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(256, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (relu): ReLU() ) ) (layer4): Sequential( (0): ResidualBlock( (left): Sequential( (0): Conv2d(256, 512, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) (2): ReLU() (3): Conv2d(512, 512, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1), bias=False) (4): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (shortcut): Sequential( (0): Conv2d(256, 512, kernel_size=(1, 1), stride=(2, 2), bias=False) (1): BatchNorm2d(512, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True) ) (relu): ReLU() ) ) (avg_pool2d): AvgPool2d(kernel_size=4, stride=4, padding=0) (fc): Linear(in_features=512, out_features=10, bias=True) ) /home/allen/.miniconda/envs/pytorch/lib/python3.7/site-packages/torch/onnx/symbolic_helper.py:446: UserWarning: ONNX export mode is set to inference mode, but operator batch_norm is set to inference mode. The model will be exported in inference, as specified by the export mode. training_mode + \", as specified by the export mode.\") ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:5","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"训练模型 def train(model, optimizer): for i in range(EPOCH): print(f\"第{i+1}次训练....\") for j, (image, label) in tqdm(enumerate(train_loader)): image = image.to(device) label = label.to(device) x = model(image) loss = loss_function(x, label) optimizer.zero_grad() loss.backward() optimizer.step() if j * BATCH_SIZE % 2000 == 0 and j != 0: print('第{}个数据，loss值等于{}'.format(j * BATCH_SIZE, loss)) train(simple_model, optimizer) simple_model.eval() ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:6","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"模型测试 def test(model, name): correct_num = torch.tensor(0).to(device) total = torch.tensor(0).to(device) for j, (data, target) in tqdm(enumerate(test_loader)): data = data.to(device) target = target.to(device) logit = model(data) pred = logit.max(1)[1] total += target.size(0) num = torch.sum(pred == target) correct_num = correct_num + num print(correct_num) print('\\n{}correct rate is {}'.format(name, correct_num / total)) test(simple_model, 'simple model') 1000it [00:10, 93.09it/s] tensor(8207, device='cuda:0') simple model correct rate is 0.8206999897956848 ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:7","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"UAP 算法 from torch.autograd import Variable import copy from torch.autograd.gradcheck import zero_gradients 无目标 Deepfool attack 算法 def Attack(image, net, max_iter=50, overshoot=0.02, num_classes=10): output = net(Variable(image.to(device), requires_grad=True)) pred = torch.argmax(output) # if pred != label.item(): # return False, pred, image, torch.zeros_like(image) adv_pred = pred # print(output) # print(pred) dist = torch.zeros_like(image) delta_Grad = torch.zeros_like(image) adv_image = copy.deepcopy(image) loop_cnt = 0 x = Variable(adv_image, requires_grad=True) adv_output = net(x) while adv_pred == pred and loop_cnt \u003c max_iter: pert = np.inf adv_output[0, pred].backward(retain_graph=True) orig_grad = x.grad.data.cpu().numpy().copy() for i in range(0, num_classes): if i == pred: continue zero_gradients(x) adv_output[0, i].backward(retain_graph=True) cur_grad = x.grad.data.cpu().numpy().copy() delta_grad = cur_grad - orig_grad delta_val = (adv_output[0, i] - adv_output[0, pred]).data.cpu().numpy().copy() pert_i = abs(delta_val) / np.linalg.norm(delta_grad.flatten()) if pert_i \u003c pert: pert = pert_i delta_Grad = delta_grad delta_dist = torch.from_numpy((pert + 0.0001) * delta_Grad / np.linalg.norm(delta_Grad)).to(device) dist = dist + delta_dist adv_image = image + (1 + overshoot) * dist x = Variable(adv_image, requires_grad=True) adv_output = net(x) adv_pred = torch.argmax(adv_output) loop_cnt += 1 return loop_cnt, dist 约束函数(uap 扰动较大，无穷范数约束效果不佳，所以以下实验均采用 2 范数约束) def project_perturbation(epsilon, p, perturbation, imagesize): perturbation = perturbation.cpu().numpy() # print(\"orgi\", perturbation) if p == 2: epsilon = epsilon * math.sqrt(imagesize[0] * imagesize[1] * imagesize[2]) perturbation = perturbation * min( 1, epsilon / np.linalg.norm(perturbation.flatten())) elif p == np.inf: perturbation = np.sign(perturbation) * np.minimum( abs(perturbation), epsilon) # exit() return torch.from_numpy(perturbation).cuda() def UAP(dataset, testset, imagesize, net, delta=0.2, p=2, epsilons=0.05, num_classes=10, overshoot=0.02, max_iter_uni=np.inf, max_iter_df=50): net.eval() v = torch.zeros([1, 3, 32, 32]) fool_rate = 0.0 best_rate = 0.0 iter_uni = 0 while fool_rate \u003c 1 - delta and max_iter_uni \u003e iter_uni: iter_uni += 1 data_loader = torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=True, pin_memory=True) net.cuda() for j, (cur_images, cur_label) in tqdm(enumerate(data_loader)): cur_image = cur_images[0].unsqueeze(0).cuda() per = Variable(cur_image + v.cuda(), requires_grad=True) if int(net(cur_image).argmax()) == int(net(per).argmax()): net.zero_grad() iter, dr = Attack(per, net, num_classes=num_classes, overshoot=overshoot, max_iter=max_iter_df) v = v.cuda() + dr.cuda() v = project_perturbation(epsilons, p, v, imagesize) if j \u003e 999: break batch_size = 10 val_loader = torch.utils.data.DataLoader(dataset=testset, batch_size=batch_size, shuffle=False) # Compute the estimated labels in batches ii = 0 adv_count = 0 with torch.no_grad(): for _, (images, labels) in tqdm(enumerate(val_loader)): for i in range(torch.numel(labels)): image = images[i].unsqueeze(0).cuda() per_image = (image + v.cuda()).cuda() ii += 1 adv_pred = net(per_image).argmax() pred = net(image).argmax() if adv_pred != pred: adv_count += 1 fool_rate = adv_count / ii if fool_rate \u003e best_rate: best_rate = fool_rate print(\"ii\", ii) print(\"adv\", adv_count) print(f\"Fool rate: {fool_rate}\") print(f\"Best fool rate: {best_rate}\") return v ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:3:8","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"Attack test dist = UAP(test_dataset, test_dataset, (3, 32, 32), simple_model) plt.figure(figsize=(33, 4)) cnt = 2 for step, (x, y) in enumerate(test_loader): plt.subplot(1, 11, 1) plt.yticks([]) plt.xticks([]) plt.ylabel(\"UAP Attack\", size=20) plt.imshow((dist[0] * 80).cpu().numpy().transpose((1, 2, 0))) for i in range(BATCH_SIZE): if cnt == 12: cnt = 13 image = x[i].unsqueeze(0).cuda() # print(torch.argmax(simple_model(adv_image))) # print(torch.argmax(simple_model(image))) image = x[i].unsqueeze(0).cuda() per_image = (image + dist.cuda()).cuda() adv_pred = simple_model(per_image).argmax() pred = simple_model(image).argmax() plt.subplot(2, 11, cnt) plt.yticks([]) plt.xticks([]) plt.title(\"{}-\u003e {}\".format(pred, adv_pred)) plt.imshow(image[0].cpu().numpy().transpose((1, 2, 0))) plt.subplot(2, 11, cnt + 1) plt.yticks([]) plt.xticks([]) plt.imshow(per_image[0].cpu().numpy().transpose((1, 2, 0))) cnt += 2 plt.show() break 1000it [00:56, 17.81it/s] 1000it [02:10, 7.66it/s] ii 10000 adv 7588 Fool rate: 0.7588 Best fool rate: 0.7588 1000it [00:45, 21.95it/s] 1000it [02:10, 7.64it/s] ii 10000 adv 7654 Fool rate: 0.7654 Best fool rate: 0.7654 1000it [00:40, 24.41it/s] 1000it [02:10, 7.67it/s] ii 10000 adv 7730 Fool rate: 0.773 Best fool rate: 0.773 1000it [00:32, 30.36it/s] 1000it [01:59, 8.39it/s] ii 10000 adv 7884 Fool rate: 0.7884 Best fool rate: 0.7884 1000it [00:32, 30.53it/s] 1000it [01:59, 8.38it/s] ii 10000 adv 7839 Fool rate: 0.7839 Best fool rate: 0.7884 1000it [00:30, 32.43it/s] 1000it [01:59, 8.39it/s] ii 10000 adv 7971 Fool rate: 0.7971 Best fool rate: 0.7971 1000it [00:31, 31.49it/s] 1000it [01:59, 8.37it/s] Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). ii 10000 adv 8140 Fool rate: 0.814 Best fool rate: 0.814 Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). 图中扰动进行了可视化处理，真实扰动比这要小 ","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:4:0","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Advesarial Attack"],"content":"Target attack 有目标的 Deepfool attack def TargetAttack(image, net, target, max_iter=50, overshoot=0.02, num_classes=10): output = net(Variable(image.to(device), requires_grad=True)) pred = torch.argmax(output) # 正常预测结果 # if pred != label.item(): # return False, pred, image, torch.zeros_like(image) adv_pred = pred # 初始化对抗样本的识别结果 # print(output) # print(pred) dist = torch.zeros_like(image) # 初始化扰动 delta_Grad = torch.zeros_like(image) # 初始化迭代梯度 adv_image = copy.deepcopy(image) # 初始化对抗样本 loop_cnt = 0 x = Variable(adv_image, requires_grad=True) adv_output = net(x) while adv_pred != target and loop_cnt \u003c max_iter: pert = np.inf adv_output[0, pred].backward(retain_graph=True) orig_grad = x.grad.data.cpu().numpy().copy() # 获取初始梯度 zero_gradients(x) adv_output[0, target].backward(retain_graph=True) cur_grad = x.grad.data.cpu().numpy().copy() # 获取其他output结果的梯度 delta_Grad = cur_grad - orig_grad # 获取梯度差 delta_val = ( adv_output[0, target] - # 获取output差 adv_output[0, pred]).data.cpu().numpy().copy() pert = abs(delta_val) / np.linalg.norm(delta_Grad.flatten()) delta_dist = torch.from_numpy((pert + 0.0001) * delta_Grad / np.linalg.norm(delta_Grad)).to(device) # 获取每次迭代的扰动 dist = dist + delta_dist adv_image = image + (1 + overshoot) * dist # 生成对抗样本 x = Variable(adv_image, requires_grad=True) adv_output = net(x) adv_pred = torch.argmax(adv_output) # 获得新的预测结果 # print(adv_pred) loop_cnt += 1 return loop_cnt, dist 主要通过抽象距离构建完全图，再利用最短路径算法提高有目标攻击的效率 def GraphBulid(image, net, num_classes=10): x = Variable(image.to(device), requires_grad=True) output = net(x) label = torch.argmax(output) grad_list = [] for i in range(num_classes): zero_gradients(x) output[0, i].backward(retain_graph=True) i_gard = x.grad.data.cpu().numpy().copy() grad_list.append(i_gard) line = [0 for i in range(num_classes)] graph = [line.copy() for i in range(num_classes)] # print(grad_list) for i in range(num_classes): for j in range(i + 1, num_classes): delta_val = (output[0, j] - output[0, i]).data.cpu().numpy().copy() delta_grad = grad_list[j] - grad_list[i] pert_ij = abs(delta_val) / np.linalg.norm(delta_grad.flatten()) graph[i][j] = pert_ij graph[j][i] = pert_ij # for i in range(num_classes): # print(graph[i]) return graph, label def FindShortPath(graph, start, end, num_classes=10): flag = [False] * num_classes distance = [graph[start][i] for i in range(num_classes)] prevetrix = [start] * num_classes prevetrix[start] = -1 count = 1 flag[start] = True while count \u003c num_classes: mindist = np.inf for i in range(num_classes): if (not flag[i] and mindist \u003e distance[i]): mindist = distance[i] min_index = i flag[min_index] = True count += 1 for i in range(num_classes): if (not flag[i] and distance[min_index] + graph[min_index][i] \u003c distance[i]): distance[i] = distance[min_index] + graph[min_index][i] prevetrix[i] = min_index path = [] index = end while index != -1: path.append(index) # print(index) index = prevetrix[index] path.reverse() # print(path) # print(prevetrix) return path def TargetAttackF(image, net, target, max_iter=50, overshoot=0.02, num_classes=10): graph, label = GraphBulid(image, net, num_classes=num_classes) path = FindShortPath(graph, label.item(), target, num_classes=num_classes) loop_cnt = 0 # print(path) for i in range(len(path) - 2): tar = path[i + 1] # print(tar) loop, _ = TargetAttack(image, net, tar, max_iter=max_iter, overshoot=overshoot, num_classes=num_classes) loop_cnt += loop loop, dist = TargetAttack(image, net, target, max_iter=max_iter, overshoot=overshoot, num_classes=num_classes) loop_cnt += loop return loop_cnt, dist def UAPTarget(dataset, testset, imagesize, net, target, delta=0.99, p=2, epsilons=0.02, num_classes=10, overshoot=0.005, max_iter_uni=np.inf, max_iter_df=50): net.eval() v = torch.zeros([1, 3, 32, 32]) fool_rate = 0.0 best_rate = 0.0 iter_uni = 0 while fool_rate \u003c 1 - delta and max_iter_uni \u003e iter_uni: iter_uni += 1 data_loader = torch.utils.data.DataLoader(dataset, batch_size=1, shuffle=True, pin_memory=True) net.cuda() for j, (cur_imag","date":"2021-11-12","objectID":"https://allen191819.xyz/uap/:5:0","tags":["Daily study","AI security"],"title":"UAP生成对抗样本(Universal adversarial perturbations)","uri":"https://allen191819.xyz/uap/"},{"categories":["Adversarial Attack"],"content":"Github 中部分经典对抗攻击库整理","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"Github 中部分经典对抗攻击库整理 部分 Github 对抗攻击库整理 nlpaug Adversarial Robustness Toolbox Foolbox Native TextAttack AdvBox Family Advertorch OpenAttack ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:0:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"nlpaug 简介：这个 python 库可以帮助你为你的机器学习项目增强自然语言处理(NLP)。augmenter是增强的基本元素，而 Flow 是将多个增强器编排在一起的管道。 特性： 无需动手即可生成用以改善模型性能的合成数据。 简单、易用、轻量 可以轻松在任何机器学习、神经网络框架中使用（scikit-learn, PyTorch, TensorFlow） 支持文本和语音输入 最近更新和最新版本：1.1.8 2021.10.18 MIT License ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:1:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"Adversarial Robustness Toolbox 简介：对抗性鲁棒性工具集（ART）是用于机器学习安全性的 Python 库。 特性： ART 提供的工具可帮助开发人员和研究人员针对以下方面捍卫和评估机器学习模型和应用程序： 逃逸，数据污染，模型提取和推断的对抗性威胁。 ART 支持所有流行的机器学习框架 （TensorFlow，Keras，PyTorch，MXNet，scikit-learn，XGBoost，LightGBM，CatBoost，GPy 等），所有数据类型 （图像，表格，音频，视频等）和机器学习任务（分类，物体检测，语音识别， 生成模型，认证等）。 对抗威胁 最近更新和最新版本：1.8.1 2021.10.15 MIT License ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:2:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"Foolbox Native 简介：Foolbox 是一个 Python 库，可让您轻松对深度神经网络等机器学习模型进行对抗性攻击。 它构建在 EagerPy 之上，并在本地与 PyTorch、TensorFlow 和 JAX 中的模型一起使用。 特性： 原生性能：Foolbox 3 构建在 EagerPy 之上，在 PyTorch、TensorFlow 和 JAX 中原生运行，并提供真正的批处理支持。 最先进的攻击：Foolbox 提供了大量最先进的基于梯度和基于决策的对抗性攻击。 类型检查：由于 Foolbox 中的大量类型注释，在运行代码之前捕获错误。 最近更新和最近版本： 3.3.1 2021.2.23 MIT License ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:3:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"TextAttack 简介：TextAttack 是一个用于对抗性攻击、数据增强和 NLP 模型训练的 Python 框架。 特性： 通过对 NLP 模型运行不同的对抗性攻击并检查输出，更好地理解它们 使用 TextAttack 框架和组件库研究和开发不同的 NLP 对抗性攻击 扩充您的数据集以提高模型的泛化能力和下游的稳健性 仅使用一个命令训练 NLP 模型（包括所有下载！） 最近更新和最新版本：0.3.3 2021.8.3 MIT License ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:4:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"AdvBox Family 简介：Advbox Family 是百度开源的一系列 AI 模型安全工具集，包括对抗样本的生成、检测和保护，以及针对不同 AI 应用的攻防案例。 AdvSDK 用于 Paddlepaddle 的轻量级 ADV SDK 以产生对抗性示例。 AdversarialBox Adversarialbox 是一个工具箱，可以在 PaddlePaddle、PyTorch、Caffe2、MxNet、Keras、TensorFlow 和 Advbox 中生成欺骗神经网络的对抗样本，可以对机器学习模型的鲁棒性进行基准测试。Advbox 提供了一个命令行工具来生成零编码的对抗样本。 它受到启发并基于 FoolBox v1。 AdvDetect AdvDetect 是一种工具箱，用于检测来自大规模数据的对抗性示例。 AdvPoison Apache License 2.0 ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:5:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"Advertorch 简介：是一个用于对抗性鲁棒性研究的 Python 工具箱。 主要功能在 PyTorch 中实现。 具体来说，AdverTorch 包含用于生成对抗性扰动和防御对抗性示例的模块，以及用于对抗性训练的脚本。 最近更新与最新版本：0.2 2021.7.30 License: This project is licensed under the LGPL. The terms and conditions can be found in the LICENSE and LICENSE.GPL files. ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:6:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"OpenAttack 简介：OpenAttack 是一个开源的基于 Python 的文本对抗性攻击工具包，它处理文本对抗性攻击的整个过程，包括预处理文本、访问受害者模型、生成对抗性示例和评估。 特性： 支持所有攻击类型。 OpenAttack 支持所有类型的攻击，包括句子/单词/字符级扰动和梯度/分数/基于决策/盲攻击模型； 多语种。 OpenAttack 现在支持英文和中文。 其可扩展的设计可以快速支持更多语言； 并行处理。 OpenAttack 提供对攻击模型多进程运行的支持，提高攻击效率； 明星与拥抱拥抱脸的兼容性。 OpenAttack 与拥抱 Transformers 和 Datasets 库完全集成； 很好的扩展性。 您可以在任何自定义数据集上轻松攻击自定义受害者模型，或开发和评估自定义攻击模型。 用途： 为攻击模型提供各种方便的基线； 使用其全面的评估指标全面评估攻击模型； 借助其常见的攻击组件，协助快速开发新的攻击模型； 评估机器学习模型对抗各种对抗性攻击的鲁棒性； 通过使用生成的对抗性示例丰富训练数据，进行对抗性训练以提高机器学习模型的鲁棒性。 最近更新和最新版本：2.1.1 2021.9.22 MIT License ","date":"2021-11-10","objectID":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/:7:0","tags":["Daily study","AI security"],"title":"Github 对抗攻击库","uri":"https://allen191819.xyz/github%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BC%80%E6%BA%90%E5%AF%B9%E6%8A%97%E6%94%BB%E5%87%BB%E5%BA%93_251021170759/"},{"categories":["Adversarial Attack"],"content":"对抗攻击入门概述","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"对抗攻击入门, 了解12种生成对抗样本的方法和15种防御方法。 Adversarial attacks概述 十二种生成对抗样本的方法 Box-constrained L-BFGS Fast Gradient Sign Method (FGSM) Basic \u0026 Least-Likely-Class Iterative Methods Jacobian-based Saliency Map Attack (JSMA) One Pixel Attack Carlini and Wagner Attacks (C\u0026W) DeepFool Universal Adversarial Perturbations UPSET and ANGRI Houdini Adversarial Transformation Networks (ATNs) Miscellaneous Attacks 防御对抗攻击的方法分类 修改训练过程/输入数据 修改网络 使用附加网络 对抗攻击是机器学习和计算机安全的结合。按照攻击者是否知道目标网络的结构参数，可以将对抗攻击分为白盒攻和黑盒攻击。 实际中，根据目的网络最终得到的分类结果是否是攻击者预先设计好的，将对抗攻击分为目标攻击和非目标攻击。 研究对抗攻击的意义如下： 能让机器学习模型处理大规模数据； 以“计算机速度”处理攻击威胁； 不依赖数据的明显特征，发现实际应用中的各种内在威胁； 阻止已知和未知的恶意软件； 阻止恶意软件的提前执行； 优化模型，让分类模型达到更加高的分类准确率和更加低的错误率。 对抗攻击的研究方向概括： 攻击原理 对抗攻击方法 对抗攻击防御 实际应用 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:0:0","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"十二种生成对抗样本的方法 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:0","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Box-constrained L-BFGS 通过对图像添加小量的人类察觉不到的扰动误导神经网络做出误分类。由求解让神经网络做出误分类的最小扰动方程转而求解简化后的问题，及寻找最小损失函数添加项，使神经网络做出误分类，进而将问题转化为凸优化过程。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:1","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Fast Gradient Sign Method (FGSM) 通过对抗训练提高深度神经网络的鲁棒性，从而提升防御对抗样本攻击的能力。通过用识别概率最小的类别（目标类别）代替对抗扰动中的类别变量，再将原始图像减去该扰动，原始图像就变成了对抗样本，并能输出目标类别。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:2","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Basic \u0026 Least-Likely-Class Iterative Methods one-step 方法通过一大步运算增大分类器的损失函数而进行图像扰动，因而可以直接将其扩展为通过多个小步增大损失函数的变体，从而我们得到 Basic Iterative Methods。该方法的变体也是通过识别概率最小的类别（目标类别）代替扰动中的类别变量，而得到 Least-Likely-Class Iterative Methods ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:3","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Jacobian-based Saliency Map Attack (JSMA) 对抗攻击文献中通常使用的方法是限制扰动的 l_∞ 或 l_2 范数的值以使对抗样本中的扰动无法被人察觉。但 JSMA 提出了限制 l_0 范数的方法，即仅改变几个像素的值，而不是扰动整张图像。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:4","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"One Pixel Attack 这是一种极端的对抗攻击方法，仅改变图像中的一个像素值就可以实现对抗攻击。使用差分进化算法，对每个像素进行迭代地修改生成子图像，并与母图像对比，根据选择标准保留攻击效果最好的子图像，实现对抗攻击。这种对抗攻击不需要知道网络参数或梯度的任何信息。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:5","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Carlini and Wagner Attacks (C\u0026W) Carlini 和 Wagner 提出了三种对抗攻击方法，通过限制 l_∞、l_2 和 l_0 范数使得扰动无法被察觉。实验证明 defensive distillation 完全无法防御这三种攻击。该算法生成的对抗扰动可以从 unsecured 的网络迁移到 secured 的网络上，从而实现黑箱攻击。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:6","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"DeepFool Moosavi-Dezfooli 等人通过迭代计算的方法生成最小规范对抗扰动，将位于分类边界内的图像逐步推到边界外，直到出现错误分类。他们生成的扰动比 FGSM 更小，同时有相似的欺骗率。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:7","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Universal Adversarial Perturbations 诸如 FGSM、ILCM、 DeepFool 等方法只能生成单张图像的对抗扰动，而 Universal Adversarial Perturbations[16] 能生成对任何图像实现攻击的扰动，这些扰动同样对人类是几乎不可见的。该论文中使用的方法和 DeepFool 相似，都是用对抗扰动将图像推出分类边界，不过同一个扰动针对的是所有的图像。虽然文中只针对单个网络 ResNet 进行攻击，但已证明这种扰动可以泛化到其它网络上。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:8","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"UPSET and ANGRI Sarkar 等人提出了两个黑箱攻击算法，UPSET 和 ANGRI。UPSET 可以为特定的目标类别生成对抗扰动，使得该扰动添加到任何图像时都可以将该图像分类成目标类别。相对于 UPSET 的「图像不可知」扰动，ANGRI 生成的是「图像特定」的扰动。它们都在 MNIST 和 CIFAR 数据集上获得了高欺骗率。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:9","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Houdini Houdini 是一种用于欺骗基于梯度的机器学习算法的方法，通过生成特定于任务损失函数的对抗样本实现对抗攻击，即利用网络的可微损失函数的梯度信息生成对抗扰动。除了图像分类网络，该算法还可以用于欺骗语音识别网络。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:10","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Adversarial Transformation Networks (ATNs) Baluja 和 Fischer 训练了多个前向神经网络来生成对抗样本，可用于攻击一个或多个网络。该算法通过最小化一个联合损失函数来生成对抗样本，该损失函数有两个部分，第一部分使对抗样本和原始图像保持相似，第二部分使对抗样本被错误分类。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:11","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"Miscellaneous Attacks 这种类型的攻击通过强制缓存服务器或 Web 浏览器来披露可能是敏感和机密的用户特定信息来利用易受攻击的 Web 服务器。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:1:12","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"防御对抗攻击的方法分类 目前，在对抗攻击防御上存在三个主要方向： 在学习过程中修改训练过程或者修改的输入样本。 修改网络，比如：添加更多层/子网络、改变损失/激活函数等。 当分类未见过的样本时，用外部模型作为附加网络。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:2:0","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"修改训练过程/输入数据 蛮力对抗训练：通过不断输入新类型的对抗样本并执行对抗训练，从而不断提高网络的鲁棒性。为了保证有效性，该方法需要使用高强度的对抗样本，并且网络架构要有充足的表达能力。这种方法需要大量的训练数据，因而被称为蛮力对抗训练。事实上无论添加多少对抗样本，都存在新的对抗攻击样本可以再次欺骗网络。 数据压缩：注意到大多数训练图像都是 JPG 格式，Dziugaite[123] 等人使用 JPG 图像压缩的方法，减少对抗扰动对准确率的影响。实验证明该方法对部分对抗攻击算法有效，但通常仅采用压缩方法是远远不够的，并且压缩图像时同时也会降低正常分类的准确率，后来提出的 PCA 压缩方法也有同样的缺点。 基于中央凹机制的防御：Luo 等人提出用中央凹（foveation）机制可以防御 L-BFGS 和 FGSM 生成的对抗扰动，其假设是图像分布对于转换变动是鲁棒的，而扰动不具备这种特性。但这种方法的普遍性尚未得到证明。 数据随机化方法：Xie 等人发现对训练图像引入随机重缩放可以减弱对抗攻击的强度，其它方法还包括随机 padding、训练过程中的图像增强等。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:2:1","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"修改网络 深度压缩网络：人们观察到简单地将去噪自编码器（Denoising Auto Encoders）堆叠到原来的网络上只会使其变得更加脆弱，因而 Gu 和 Rigazio 引入了深度压缩网络（Deep Contractive Networks），其中使用了和压缩自编码器（Contractive Auto Encoders）类似的平滑度惩罚项。 梯度正则化/ masking：使用输入梯度正则化以提高对抗攻击鲁棒性，该方法和蛮力对抗训练结合有很好的效果，但计算复杂度太高。 Defensive distillation：distillation 是指将复杂网络的知识迁移到简单网络上，由 Hinton 提出。Papernot 利用这种技术提出了 Defensive distillation，并证明其可以抵抗小幅度扰动的对抗攻击。 生物启发的防御方法：使用类似与生物大脑中非线性树突计算的高度非线性激活函数以防御对抗攻击。另外一项工作 Dense Associative Memory 模型也是基于相似的机制。 Parseval 网络：在一层中利用全局 Lipschitz 常数加控制，利用保持每一层的 Lipschitz 常数来摆脱对抗样本的干扰。 DeepCloak：在分类层（一般为输出层）前加一层特意为对抗样本训练的层。它背后的理论认为在最显著的层里包含着最敏感的特征。 混杂方法：这章包含了多个人从多种角度对深度学习模型的调整从而使模型可以抵抗对抗性攻击。 仅探测方法：4 种网络，SafetyNet，Detector subnetwork，Exploiting convolution filter statistics 及 Additional class augmentation。 SafetyNet 介绍了 ReLU 对对抗样本的模式与一般图片的不一样，文中介绍了一个用 SVM 实现的工作。 Detector subnetwork 介绍了用 FGSM, BIM 和 DeepFool 方法实现的对对抗样本免疫的网络的优缺点。 Exploiting convolution filter statistics 介绍了同 CNN 和统计学的方法做的模型在分辨对抗样本上可以有 85% 的正确率。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:2:2","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"使用附加网络 防御通用扰动:利用一个单独训练的网络加在原来的模型上，从而达到不需要调整系数而且免疫对抗样本的方法。 基于 GAN 的防御:用 GAN 为基础的网络可以抵抗对抗攻击，而且作者提出在所有模型上用相同的办法来做都可以抵抗对抗样本。 仅探测方法：介绍了 Feature Squeezing、MagNet 以及混杂的办法。 Feature Squeezing 方法用了两个模型来探查是不是对抗样本。后续的工作介绍了这个方法对 C\u0026W 攻击也有能接受的抵抗力。 MagNet:作者用一个分类器对图片的流行（manifold）测量值来训练，从而分辨出图片是不是带噪声的。 混杂方法（Miscellaneous Methods）：作者训练了一个模型，把所有输入图片当成带噪声的，先学习怎么去平滑图片，之后再进行分类。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattacks_241021180957/:2:3","tags":["Daily study","AI security"],"title":"对抗攻击概述","uri":"https://allen191819.xyz/adversarialattacks_241021180957/"},{"categories":["Adversarial Attack"],"content":"对于FGSM, C\u0026W, UAP等经典对抗攻击方法的学习笔记。","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"对于FGSM, C\u0026W, UAP等经典对抗攻击方法的学习笔记。 adversarial attacks C\u0026W 基本方法 objective function 对于常量 $c$ 处理盒约束 C\u0026W Attack 中选择不同 objective function 和 box constraint 的结果 FGSM(fast gradient sign method) 对于样本的线性解释 对于非线性模型的线性扰动 深层神经网络的对抗训练 总结 UAP Attack 算法思想 算法表述 攻击结果 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:0:0","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"C\u0026W (参考：《Towards evaluating the robustness of neural networks》（2017.3）) ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:1:0","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"基本方法 寻找对抗样本的过程总归就是一个盒约束的优化问题: $$ minimize\\ D(x,x+\\delta) $$ $$ such\\ that\\ C(x+\\delta)=t $$ $$ x+\\delta \\in[0,1]^n $$ 在这里，D 是距离度量，$C(x+\\delta)=t$ 代表网络将对抗样本分类为预设的目标 $t$，我们希望找到一个使得对抗样本与干净样本某种距离度量下具有最小的距离，同时满足，对抗样本的被模型错分为另一类别（可以分为目标攻击和无目标攻击），以及对抗样本要满足自然图片的 RGB 信息约束。 将 $C(x+\\delta)=t$ 这样一个约束变为一个等价的 objective function，来和 $D(x,x+\\delta)$ 一起来进行优化，使得产生的扰动 $\\delta$ 满足 $x+\\delta \\in[0,1]^n$ 这个约束。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:1:1","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"objective function 对于 objective function $f$ ，使得 $C(x+\\delta)=t$ 当且仅当 $f(x+\\delta)\\leq 0$ 其中 $x\\prime=x+\\delta$ $Loss_{F,t}(x\\prime)$ 代表分类器输出和目标 $t$ 的 cross entropy $soflplus(x)=log(1+e^x)$ $Z$ 代表无 softmax 的网络，$F$ 代表有 softmax 的网络 $(e)^+$ 代表 $max(0,e)$ 原先的式子可以进行替换 $$ minimize\\ D(x,x+\\delta)+c\\cdot f(x+\\delta) $$ $$ such\\ that \\ x+\\delta \\in[0,1]^n $$ 再将距离度量 $D$ 定义为 $p$ 范数，就得到： $$ minimize\\ |\\delta|_p +c\\cdot f(x+\\delta) $$ $$ such\\ that \\ x+\\delta \\in[0,1]^n $$ ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:1:2","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"对于常量 $c$ 当 $c=1$ 时较合适 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:1:3","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"处理盒约束 Projected gradient descent Clipped gradient descent Change of variables ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:1:4","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"C\u0026W Attack 中选择不同 objective function 和 box constraint 的结果 使用 Best Case, Average Case, Worst Case 进行实验 其中 $f_6$ 表现最好 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:1:5","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"FGSM(fast gradient sign method) (参考：《Explaining And Harnessing Adversarial Examples》（2015.3）) ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:2:0","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"对于样本的线性解释 由于数字图像通常每个像素使用 8 位来表述，导致特征精度是有限的，所以会丢失低于动态范围 1/255 的信息。故对于扰动 $\\eta$ 的每个元素都小于特征精度，希望分类器对于输入 $x$ 的相应与对抗输入 $\\tilde{x} = x + \\eta$ 做出不同相应是不合理的。想要 $x$ 和 $\\tilde{x}$ 响应出相同的类别，则需要 $|\\eta|_\\infty \u003c\\epsilon$ ，其中 $\\epsilon$ 可以忽略 权重向量 $w$ 和对抗样本 $\\tilde{x}$ 的乘积可以表述为： $$w^{T}\\tilde{x} = w^{T}x+w^T\\eta$$ 通过赋予 $\\eta=sign(w)$ ，在 $\\eta$ 上受大最大范数约束的情况下最大化此激活。对于 $n$ 维平均权重向量为 $m$ 的权重向量$w$ ，这种激活将以 $\\epsilon mn$ 的形式增加，随着维度增加，此时对于输入的微小改变则会引起输出较大的改变。 此说明表明，如果简单线性模型的输入具有足够的维度，则可以具有对抗样本。 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:2:1","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"对于非线性模型的线性扰动 设 $\\theta$ 为模型参数， $x$ 为模型输入， $y$ 是和 $x$ 相关联的目标，神经网络的损失函数为 $J(\\theta,x,y)$ 。可以围绕 $\\theta$ 的当前值来线性化损失函数，以获得： $$\\eta=\\epsilon sign(\\nabla_xJ(\\theta,x,y))$$ 的最优最大范数约束下的扰动。称之为快速梯度符号方法 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:2:2","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"深层神经网络的对抗训练 通过训练对抗样本和干净样本的混合，可以对神经网络进行一定程度的正则化。关于对抗样本的训练与其他数据增强方案有所不同。通常，人们会使用转换（例如预期在测试集中实际发生的转换）来扩充数据。相反，这种形式的数据增强使用了不太可能自然发生的输入，但暴露了以模型概念化其决策功能的方式的缺陷。当时，从未证明此程序可以改进以达到最新基准水平。但是，这部分是因为很难对基于 L-BFGS 的昂贵的对抗样本进行广泛的实验。 基于快速梯度符号法(FGSM)的对抗目标函数训练是一种有效的正则化器： $$\\tilde{J}(\\theta,x,y)=\\alpha J(\\theta,x,y)+(1-\\alpha)J(\\theta,x+\\epsilon sign(\\nabla_x J(\\theta,x,y)))$$ ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:2:3","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"总结 对抗样本可以解释为高维点积的属性，它们是模型过于线性而不是非线性的结果 跨不同模型的对抗样本的泛化可以解释为对抗性扰动与模型的权重向量高度一致的结果，不同的模型在训练执行相同的任务时学习相似的功能。 最重要的是扰动的方向，而不是空间中的特定点。 易于优化的的模型很容易受到干扰 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:2:4","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"UAP Attack ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:3:0","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"算法思想 对于一个数据点集 $x$ ,希望找到一个向量 $v$ 可以迷惑分类器 $\\hat{k}$ 使得： $$ \\hat{k}(x+v)\\neq \\hat{k}(x) \\ for \\ most \\ x\\backsim \\mu $$ 同时对于这样一个扰动 $v$ 存在约束 $|v| _ p \u003c \\xi$ $P_{x \\backsim \\mu}(\\hat{k}(x+v) \\neq \\hat{k}(x))\\leq 1-\\delta$ 如图所示，通过多次迭代，使用每次迭代获得的 $v_i$ 一步步将 $x$ 数据点从原本三个类别重合的区域分类到 $R_3$ ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:3:1","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"算法表述 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:3:2","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":["Adversarial Attack"],"content":"攻击结果 图中扰动进行了可视化处理，真实扰动比这要小 ","date":"2021-11-10","objectID":"https://allen191819.xyz/adversarialattackmethod/:3:3","tags":["Daily study","AI security"],"title":"对抗攻击方法","uri":"https://allen191819.xyz/adversarialattackmethod/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \" Hugo Theme LoveIt ","date":"2019-08-02","objectID":"https://allen191819.xyz/about/:0:0","tags":null,"title":"About LoveIt","uri":"https://allen191819.xyz/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"https://allen191819.xyz/about/:0:1","tags":null,"title":"About LoveIt","uri":"https://allen191819.xyz/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"https://allen191819.xyz/about/:0:2","tags":null,"title":"About LoveIt","uri":"https://allen191819.xyz/about/"}]